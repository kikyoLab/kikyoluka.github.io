<!DOCTYPE html><html lang="ZH-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="author" content="琉花"><meta name="copyright" content="琉花"><meta name="og:image" content="/images/avatar.png"><meta name="og:type" content="website"><meta name="og:site_name" content="琉花"><meta name="og:url" content="kikyoluka.cn"><meta name="og：title" content="琉花"><meta name="theme-color" content="#b854d4" /><title>琉花</title><link rel="shortcut icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/index.css?version=2.0.0"><link rel="stylesheet" href="/font/fontello.css?version=2.0.0"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Mono|Noto+Serif+SC&amp;amp;display=swap"><link rel="canonical" href="//kikyoluka.cn"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script src="/lib/gitalk/gitalk.min.js"></script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="layout"><header><div class="header"><div class="mobile-bg" style="background-image:url(/images/mobile.png);"></div><h1 class="title">琉花</h1><h2 class="subtitle">行至朝雾里 坠入暮云间</h2><nav class="menu"><a class="menu-item pjax-main-link" href="/"><li><i class="icon-index"></i><span>首页</span></li></a><a class="menu-item pjax-main-link" href="/archives/"><li><i class="icon-archives"></i><span>归档</span></li></a><a class="menu-item pjax-main-link" href="/categories/"><li><i class="icon-categories"></i><span>分类</span></li></a><a class="menu-item pjax-main-link" href="/tags/"><li><i class="icon-tags"></i><span>标签</span></li></a><a class="menu-item pjax-main-link" href="/books/"><li><i class="icon-books"></i><span>书单</span></li></a><a class="menu-item pjax-main-link" href="/inspirations/"><li><i class="icon-inspiration"></i><span>灵感</span></li></a><a class="menu-item pjax-main-link" href="/friends/"><li><i class="icon-friends"></i><span>友链</span></li></a><a class="menu-item pjax-main-link" href="/about/"><li><i class="icon-about"></i><span>关于</span></li></a></nav></div></header><main><div class="main-wrapper"></div><div class="pjax-main-page"><div class="post"><article class="post-article"><div class="post-header"><img class="default-image" src="/images/postDefaultImage%20.png" style="opacity:0;"/><img class="post-image" src="https://cdn.jsdelivr.net/gh/chanshiyucx/yoi@latest/bg/35.jpg"/><div class="post-head"><div class="post-title-wrapper"><h1 class="post-title">前端面试题的整理-AJAX部分</h1><span class="post-image-source">pixiv</span></div><div class="post-meta"><span class="post-date"><i class="icon-calendar"></i><span class="date timeago" datetime="2019-11-28T02:10:10.000Z"></span></span><span class="post-hot"><i class="icon-fire"></i><span class="leancloud_visitors" id="/2019/11/28/article4/" data-flag-title="前端面试题的整理-AJAX部分">热度<span class="leancloud-visitors-count">0</span>℃</span></span><span class="post-tags"><i class="icon-tag"></i><span class="tag">面试知识</span></span><span class="post-categories"><i class="icon-bookmark-empty"></i><span class="category">笔记</span></span></div></div></div><div class="post-content"><div class="markdown"><h1 id="什么是AJAX，AJAX原理？"><a href="#什么是AJAX，AJAX原理？" class="headerlink" title="什么是AJAX，AJAX原理？"></a>什么是AJAX，AJAX原理？</h1><p><code>AJAX = Asynchronous JavaScript and XML</code>（异步的 JavaScript 和 XML）</p>
<p>AJAX 是一种用于创建快速动态网页的技术，通过在后台与服务器进行少量数据交换，可以使网页实现异步更新</p>
<p>这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新；传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面；有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等</p>
<h1 id="AJAX的工作原理和流程"><a href="#AJAX的工作原理和流程" class="headerlink" title="AJAX的工作原理和流程"></a>AJAX的工作原理和流程</h1><p>第一步，创建ajax对象  <code>var xxx = new XMLHttpRequest()</code>;<br>第二步，判断数据传输方式（GET / POST）<br>第三步，绑定请求地址，打开链接open。 即 <code>open(method,url,async)</code>；<br>第四步，发送send。即开始请求 <code>send(string)</code> string：仅用于 POST 请求<br>第五步，获取请求结果。</p>
<p>注意：检测XMLHttpRequest对象的readyState属性，该属性表示请求 /响应过程的当前活动及阶段，属性值如下：</p>
<ol start="0">
<li>未初始化,尚未调用open方法</li>
<li>启动,已经调用open方法，但尚未调用open方法</li>
<li>发送,已经调用open方法，尚未接到响应</li>
<li>接受,已经接受到部分响应数据</li>
<li>完成,已经接受到全部响应数据</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-719cc67e00e002601381cc9f30235343_hd.png" alt="img"></p>
<h1 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h1><ul>
<li>GET方式<br>用get方式可传送简单数据，但大小一般限制在1KB下，数据追加到url中发送（http的header传送），也就是说：<br>  <strong>浏览器将各个表单字段元素及其数据按照URL参数的格式附加在请求行中的资源路径后面</strong></li>
</ul>
<p>另外最重要的一点是，它会被客户端的浏览器缓存起来，那么，别人就可以从浏览器的历史记录中，读取到此客户的数据，比如帐号和密码等。因此，在某些情况下，get方法会带来严重的安全性问题</p>
<pre><code>function getAjax(){   

     //获取xhr对象  
     var xhr = getXhr();  
     //规定请求类型       
     xhr.open(&quot;get&quot;,&quot;main.jsp?username=123&quot;,true);  
     //发送请求  
     xhr.send();  
    //处理服务器响应事件  
     xhr.onreadystatechange = function (){  
          //判读是否处理完毕 与判读服务器是否处理成功！  
          if(xhr.readyState==4 &amp;&amp; xhr.status==200){  
                    alert(xhr.responseText);  
              }  
          }  
      }   
}</code></pre><ul>
<li>POST方式<br>当使用POST方式时，浏览器把各表单字段元素及其数据作为HTTP消息的实体内容发送给Web服务器，而不是作为URL地址的参数进行传递，使用POST方式传递的数据量要比使用GET方式传送的数据量大的多发送请求</li>
</ul>
<pre><code>function postAjax(){   
     //获取xhr对象  
     var xhr = getXhr();  
     //规定请求类型       
     xhr.open(&quot;post&quot;,&quot;main.jsp&quot;,true);  
    //设置头信息  
     xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)  
 //发送参数  
 xhr.send(&quot;username=345&amp;pass=123&quot;);  
//相应事件处理  
   xhr.onreadystatechange = function (){  
  //判读是否处理完毕 与判读服务器是否处理成功！  
      if(xhr.readyState==4 &amp;&amp; xhr.status==200){  
                    alert(xhr.responseText);  
              }  
    }   
}  </code></pre><ul>
<li>区别</li>
</ul>
<ol>
<li><p>GET在浏览器回退时是无害的，而POST会再次提交请求</p>
</li>
<li><p>GET产生的URL地址可以被Bookmark，而POST不可以</p>
</li>
<li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置</p>
</li>
<li><p>GET请求只能进行url编码，而POST支持多种编码方式</p>
</li>
<li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p>
</li>
<li><p>get方式提交数据的大小（一般来说1024字节），http协议并没有硬性限制，而是与浏览器、服务器、操作系统有关，而POST理论上来说没有大小限制，http协议规范也没有进行大小限制，但实际上post所能传递的数据量根据取决于服务器的设置和内存大小</p>
</li>
<li><p>对参数的数据类型，GET只接受<code>ASCII</code>字符，而POST没有限制</p>
</li>
<li><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</p>
</li>
<li><p>GET参数通过URL传递，POST放在<code>Request body</code>中</p>
</li>
</ol>
<blockquote>
<p>重要区别：</p>
<ol>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包</li>
</ol>
<ul>
<li>对于GET方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）；</li>
<li>而对于POST，浏览器发送<code>header</code>，服务器响应100 continue，浏览器再发送<code>data</code>，服务器响应200 ok（返回数据）</li>
</ul>
<ol start="2">
<li>GET与POST都有自己的语义，不能随便混用</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视；而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</li>
<li>get一般是用来获取数据，post提交数据</li>
<li>post其实是有大小限制的，只不过是取决于服务器的设置和内存大小。</li>
<li>还有更深入的区别：GET是用来向获取服务器信息的，请求报文传输的信息只是用于描述所需资源的参数，返回的信息才是数据本身；POST是用来向服务器传递数据的，其请求报文传递的信息就是数据本身，返回的报文只是操作的结果</li>
</ol>
</blockquote>
<h1 id="GET和POST两种方式的优缺点"><a href="#GET和POST两种方式的优缺点" class="headerlink" title="GET和POST两种方式的优缺点"></a>GET和POST两种方式的优缺点</h1><p><img src="https://pic3.zhimg.com/80/v2-d971de8764ccb05a0b287e98f3727702_hd.png" alt="img"></p>
<h1 id="一次完整的http事物是怎样的一个过程"><a href="#一次完整的http事物是怎样的一个过程" class="headerlink" title="一次完整的http事物是怎样的一个过程"></a>一次完整的http事物是怎样的一个过程</h1><p><img src="https://pic4.zhimg.com/80/v2-23b23fd5eae76ce4d331030c29898457_hd.png" alt="img"></p>
<h1 id="跨域的方法及其原理"><a href="#跨域的方法及其原理" class="headerlink" title="跨域的方法及其原理"></a>跨域的方法及其原理</h1><ol>
<li><p>jsonp是用script标签的src属性是不跨域的这一性质，所以其实是封装了这个功能而已，jquery会创建一个script标签，把src的地址指向后端，src会带一个callback参数，一般是一个函数名，后端根据这个请求，获取参数，然后把需要返回的数据包裹在这个函数内，前端获得了这些js代码，就会执行这个callback，自然就把数据传到客户端了（只支持GET请求）</p>
</li>
<li><p><code>cors(cross-origin resource sharing)</code>就是服务端加上一句<code>header(“Access-Control-Allow-Origin:*”)</code>;支持所有请求，但是兼容性不太好，支持IE8+,chrome3+</p>
</li>
<li><p>window.name.一个窗口window的生命周期内，窗口载入的页面共享一个window.name,每个页面都有读写权限, data.html里面就写上window.name=”data..”;然后在a.html里用一个隐藏的iframe载入data.html,然后在a.html里用js把iframe的src设为同源的一个页面</p>
</li>
<li><p>修改document.domain的方法只适用于不同子域的框架间的交互；比如<code>http://www.example.com/a.html</code>和<code>http://example.com/b.html</code>在两个页面中都修改 document.domain 为 <code>&quot;example.com&quot;</code></p>
</li>
<li><p>img标签的src也是不跨域的，所以可以<code>img.src = http://example.com/data?value=123</code>，但是这种方法只能用来发送请求</p>
</li>
<li><p>HTML5有一个<code>postMessage(data,origin)</code>方法，可以向当前页面中的iframe或者当前页弹出的窗口发送消息</p>
</li>
</ol>
<h1 id="使用-Ajax-都有哪些优劣"><a href="#使用-Ajax-都有哪些优劣" class="headerlink" title="使用 Ajax 都有哪些优劣?"></a>使用 Ajax 都有哪些优劣?</h1><p><strong>优势：</strong>  </p>
<ol>
<li><p>无刷新在页面与服务器通信，更新页面，用户体验好</p>
</li>
<li><p>异步与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力</p>
</li>
<li><p>前端和后端负载平衡</p>
</li>
</ol>
<ul>
<li>可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本，并且减轻服务器的负担；</li>
<li>ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担</li>
</ul>
<ol start="4">
<li>界面与应用分离</li>
</ol>
<ul>
<li>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统</li>
</ul>
<ol start="5">
<li>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>AJAX干掉了Back和History功能，即对浏览器机制的破坏</p>
</li>
<li><p>AJAX的安全问题</p>
</li>
</ol>
<ul>
<li>Ajax技术就如同对企业数据建立了一个直接通道，这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑；Ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于Credentials的安全漏洞等等</li>
</ul>
<ol start="3">
<li><p>对搜索引擎支持较弱</p>
</li>
<li><p>客户端过肥，太多客户端代码造成开发上的成本</p>
</li>
<li><p>违背URL和资源定位的初衷,采用了Ajax技术，也许你在该URL地址下面看到的和我在这个URL地址下看到的内容是不同的</p>
</li>
</ol>
<h1 id="请解释-JSONP-的工作原理，以及它为什么不是真正的-Ajax"><a href="#请解释-JSONP-的工作原理，以及它为什么不是真正的-Ajax" class="headerlink" title="请解释 JSONP 的工作原理，以及它为什么不是真正的 Ajax"></a>请解释 JSONP 的工作原理，以及它为什么不是真正的 Ajax</h1><ol>
<li>JSONPS 是利用<code>&lt;script&gt;</code> 标签没有同源策略的限制（算是一个漏洞），来达到与第三方通信，从而实现跨域</li>
</ol>
<ul>
<li>我们通常使用js代码动态创建一个script标签，src引用第三方api的地址，并提供一个回调函数的<code>function name</code>，例如<code>http://www.smartstudy.com/api?callback=functionName</code> ,query的key是约定好的，比如这里就叫callback，functionName是我们前端定义好的函数，后端通过query取到函数名，并把你所需要的数据已参数的形式传给这个函数，返回给浏览器；浏览器解析服务器返回数据，functionName函数，参数为资源数据</li>
</ul>
<blockquote>
<p>JSONP并不使用XMLHttpRequest对象加载资源，而是通过script标签把资源当做普通的javascript脚本来加载，所以不存在跨域问题，也不是真正的AJAX</p>
</blockquote>
</div></div></article></div><div id="gitalk"></div><script>var gitalk = new Gitalk({
    clientID: '007c2e64322ff31b60e9',
    clientSecret: '889ab344b75944a36ccb79dff864e51063bfa5bd',
    id: '2019-11-28 10:10:10',
    repo: 'comments',
    owner: 'kikyoluka',
    admin: 'kikyoluka'
})
gitalk.render('gitalk')</script></div><div class="pjax-main-loading loading"><img class="loading-image" src="/images/loading.gif"></div></main><footer><div class="footer site-info"><p><i class="icon-copyright"></i><span>2018</span>&minus;<span>2020</span>&nbsp;&nbsp;&nbsp;<i class="icon-heart"></i>&nbsp;&nbsp;<span>琉花</span></p><p><a href="https://github.com/sanshiliuxiao/hexo-theme-aurora.git" target="_blank">hexo-theme-Aurora</a>&nbsp; | &nbsp;行至朝雾里 坠入暮云间</p></div></footer></div><div class="bg"><div class="pc-dynamic-bg"><span class="image" data-image="/images/theme/1.jpg"></span><span class="image" data-image="/images/theme/2.jpg"></span><span class="image" data-image="/images/theme/3.jpg"></span><span class="image" data-image="/images/theme/4.jpg"></span><span class="image" data-image="/images/theme/5.jpg"></span><span class="image" data-image="/images/theme/6.jpg"></span><span class="image" data-image="/images/theme/7.jpg"></span><span class="image" data-image="/images/theme/8.jpg"></span><span class="image" data-image="/images/theme/9.jpg"></span></div></div><span class="back-to-top"></span><div class="leancloud"><script src="/js/third-party/leancloud.min.js?version=2.0.0"></script><div class="leancloud-app-id" leancloud-app-id="LjOwR4ELEqbauKvtQbwq5TUw-MdYXbMMI"></div><div class="leancloud-app-key" leancloud-app-key="BOSFJ49ohbGctgn4zvJE9VN6"></div><div class="leancloud-app-hot"></div><div class="leancloud-app-visitor"></div></div><link rel="stylesheet" href="/lib/APlayer/APlayer.min.css"><script src="/lib/APlayer/APlayer.min.js"></script><div id="aplayer"></div><script>let list = JSON.parse('[{"name":"Julia，Train，Slow Down","artist":"Whale Fall","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/JuliaTrainSlowDown.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/5.jpg"},{"name":"The Wellwisher","artist":"Halves","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/TheWellwisher.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/4.jpg"},{"name":"SadSexy","artist":"Dirty Three","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/SadSexy .mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/1.jpg"},{"name":"Riverrun","artist":"Stubborn","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/Riverrun.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/3.jpg"},{"name":"Hortur","artist":"Picastro","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/Hortur.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/2.jpg"}]')
  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      theme: '#b28fce',
      audio: list,
      fixed: true,
      volume: 1
  });
  ap.list.show()
</script><script src="/js/third-party/jquery.min.js?version=2.0.0"></script><script src="/js/third-party/isMobile.min.js?version=2.0.0"></script><script src="/js/third-party/timeago.min.js?version=2.0.0"></script><script src="/js/third-party/pjax.min.js?version=2.0.0"></script><script src="/js/third-party/zooming.min.js?version=2.0.0"></script><script src="/js/third-party/backstretch.min.js?version=2.0.0"></script><script src="/js/highlight.min.js?version=2.0.0"></script><script src="/js/index.js?version=2.0.0"></script></body></html>
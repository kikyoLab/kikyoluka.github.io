<!DOCTYPE html><html lang="ZH-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="author" content="琉花"><meta name="copyright" content="琉花"><meta name="og:image" content="/images/avatar.png"><meta name="og:type" content="website"><meta name="og:site_name" content="琉花"><meta name="og:url" content="kikyoluka.cn"><meta name="og：title" content="琉花"><meta name="theme-color" content="#b854d4" /><title>琉花</title><link rel="shortcut icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/index.css?version=2.0.0"><link rel="stylesheet" href="/font/fontello.css?version=2.0.0"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Mono|Noto+Serif+SC&amp;amp;display=swap"><link rel="canonical" href="//kikyoluka.cn"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script src="/lib/gitalk/gitalk.min.js"></script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="layout"><header><div class="header"><div class="mobile-bg" style="background-image:url(/images/mobile.png);"></div><h1 class="title">琉花</h1><h2 class="subtitle">行至朝雾里 坠入暮云间</h2><nav class="menu"><a class="menu-item pjax-main-link" href="/"><li><i class="icon-index"></i><span>首页</span></li></a><a class="menu-item pjax-main-link" href="/archives/"><li><i class="icon-archives"></i><span>归档</span></li></a><a class="menu-item pjax-main-link" href="/categories/"><li><i class="icon-categories"></i><span>分类</span></li></a><a class="menu-item pjax-main-link" href="/tags/"><li><i class="icon-tags"></i><span>标签</span></li></a><a class="menu-item pjax-main-link" href="/books/"><li><i class="icon-books"></i><span>书单</span></li></a><a class="menu-item pjax-main-link" href="/inspirations/"><li><i class="icon-inspiration"></i><span>灵感</span></li></a><a class="menu-item pjax-main-link" href="/friends/"><li><i class="icon-friends"></i><span>友链</span></li></a><a class="menu-item pjax-main-link" href="/about/"><li><i class="icon-about"></i><span>关于</span></li></a></nav></div></header><main><div class="main-wrapper"></div><div class="pjax-main-page"><div class="post"><article class="post-article"><div class="post-header"><img class="default-image" src="/images/postDefaultImage%20.png" style="opacity:0;"/><img class="post-image" src="https://cdn.jsdelivr.net/gh/chanshiyucx/yoi@latest/bg/21.jpg"/><div class="post-head"><div class="post-title-wrapper"><h1 class="post-title">前端面试题的整理-JS部分</h1><span class="post-image-source">pixiv</span></div><div class="post-meta"><span class="post-date"><i class="icon-calendar"></i><span class="date timeago" datetime="2019-12-20T02:10:10.000Z"></span></span><span class="post-hot"><i class="icon-fire"></i><span class="leancloud_visitors" id="/2019/12/20/article5/" data-flag-title="前端面试题的整理-JS部分">热度<span class="leancloud-visitors-count">0</span>℃</span></span><span class="post-tags"><i class="icon-tag"></i><span class="tag">面试知识</span></span><span class="post-categories"><i class="icon-bookmark-empty"></i><span class="category">笔记</span></span></div></div></div><div class="post-content"><div class="markdown"><h1 id="1-事件代理-event-delegation"><a href="#1-事件代理-event-delegation" class="headerlink" title="1-事件代理 (event delegation)"></a>1-事件代理 (event delegation)</h1><p>事件代理，即把一个元素响应事件（click、keydown……）的函数委托到另一个元素</p>
<p>一般来说会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p>
<p><strong>那么事件冒泡机制又是什么？</strong><br><strong>“DOM2级事件”规定事件流包括三个阶段</strong>，事件捕获阶段、处于目标阶段和事件冒泡阶段；<strong>首先发生的事件捕获</strong>，为截获事件提供了机会；然后是<strong>实际的目标接收了事件</strong>；最后一个阶段是<strong>冒泡阶段</strong>，可以在这个阶段对事件做出响应</p>
<ul>
<li><strong>事件捕获阶段</strong>：当鼠标点击或者触发dom事件时，浏览器会<strong>从根节点开始由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</li>
</ul>
<ul>
<li><strong>事件目标阶段</strong>：目标阶段就是指事件响应到触发事件的最底层元素上；</li>
</ul>
<ul>
<li><strong>事件冒泡阶段</strong>：冒泡阶段就是事件的触发响应会<strong>从最底层目标一层层地向外到最外层（根节点）</strong>，事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>
</ul>
<ol>
<li><p>事件捕获：<br><img src="https://segmentfault.com/img/remote/1460000012729086" alt="img"></p>
<br />
</li>
<li><p>事件冒泡:<br><img src="https://segmentfault.com/img/remote/1460000012729085" alt="img"></p>
<br />
</li>
<li><p>一个完整的事件流程：<br>从根节点开始一直到目标点，然后再从目标点到根节点<br><img src="https://pic1.zhimg.com/80/v2-4de189d2a42b1e8c74b379e067b67578_hd.jpg" alt="img"></p>
<br />

</li>
</ol>
<p><strong>说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent（<del>当然还有其它的事件绑定的方式这里不做介绍</del>）</strong></p>
<p><strong>addEventListener(event, listener, useCapture)</strong></p>
<p>参数定义：<br>event—（事件名称，如click，不带on）<br>listener—事件监听函数<br>useCapture—是否采用事件捕获进行事件捕捉（默认为false，即采用事件冒泡方式）<br>addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持</p>
<p>那么我们从代码上来看：</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;style&gt;
      #a{
          width: 300px;
          height: 300px;
          background: pink;
      }
      #b{
          width: 200px;
          height: 200px;
          background: blue;
      }
    #c{
        width: 100px;
        height: 100px;
        background: yellow;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;a&quot;&gt;
        &lt;div id=&quot;b&quot;&gt;
            &lt;div id=&quot;c&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;script&gt;
      var a = document.getElementById(&quot;a&quot;),
          b = document.getElementById(&quot;b&quot;),
          c = document.getElementById(&quot;c&quot;);

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c1&quot;);
          // 注意第三个参数没有传进 false , 因为默认传进来的是 false
          //，代表冒泡阶段调用，个人认为处于目标阶段也会调用的
      });

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c2&quot;);
      }, true);

      b.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;b&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a1&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a2&quot;)
      });

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a3&quot;);
          event.stopImmediatePropagation();
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a4&quot;);
      }, true);
  &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li><p>在这个代码中，如果点击c和b的话，根据DOM事件流，应该先从事件捕获开始，那么自然就是从a开始往目标事件进行事件捕获；而代码中只有a1、a3、a4为捕获阶段（因为其addEventListener的第三个参数为true，默认为false–即采用事件冒泡方式），但是a3的event.stopImmediatePropagation();阻止事件的传播（捕获或冒泡），同时也阻止该元素上后来绑定的事件处理程序被调用，所以整个代码就直接被结束了，故只输出a1、a3</p>
<br />
</li>
<li><p>如果点击a的话，目标事件就在a，事件流既不属于捕获也不属于冒泡，事件流处于目标阶段，所以直接按顺序输出a1、a2、a3</p>
<br />
</li>
<li><p>如果注释掉event.stopImmediatePropagation();再点击c的话，从捕获开始a1、a3、a4、b然后到目标阶段c1、c2然后到冒泡阶段a2</p>
<br />

</li>
</ul>
<blockquote>
<p>为什么冒泡阶段不全部再触发一次呢？因为如果同一个事件处理程序（指针相同，比如用 <code>handler</code> 保存的事件处理程序），用 <code>addEventListener</code>或 <code>attachEvent</code>绑定多次，如果第三个参数是相同的话，也只会被调用一次。当然，如果第三个参数一个设置为<code>true</code>，另一个设置为<code>false</code>，那么会被调用两次</p>
</blockquote>
<p><strong>事件委托的优点：</strong></p>
<ol>
<li><p>减少内存消耗<br>试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
  ......
  &lt;li&gt;item n&lt;/li&gt;
&lt;/ul&gt;
// ...... 代表中间还有未知数个 li</code></pre><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件的时候再去匹配判断目标元素；所以事件委托可以减少大量的内存消耗，节约效率</p>
<br />
</li>
<li><p>动态绑定事件<br>比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的</p>
</li>
</ol>
<h1 id="2-JavaScript-中-this-是如何工作的"><a href="#2-JavaScript-中-this-是如何工作的" class="headerlink" title="2-JavaScript 中 this 是如何工作的"></a>2-JavaScript 中 <code>this</code> 是如何工作的</h1><p>在JavaScript中<code>this</code>的指向总是让人很困惑，它到底指的是什么？为了彻底弄清它,我们就来探讨一下吧。<code>this</code>在不同的执行环境，不同的用法下会有所不同，以下分几种情况，讨论<code>this</code>的指向</p>
<p><strong>this在全局作用域中</strong>:</p>
<pre><code>// global scope

foo = &#39;abc&#39;;
alert(foo); // abc

this.foo = &#39;def&#39;;
alert(foo); // def</code></pre><p>在全局作用域/全局环境(global scope| global context)中，<code>this</code>指向的就是全局变量，所以上面代码中的<code>this.foo</code>其实就是全局中的<code>foo</code></p>
<ul>
<li>在浏览器里,指向<code>window</code>对象</li>
<li>在Node.js里，指向<code>global</code>对象</li>
</ul>
<br />

<p><strong>this在函数(function)里</strong>:</p>
<pre><code>var boat = {
    size: &#39;normal&#39;,
    boatInfo: function() {
        alert(this === boat);   
        alert(this.size);   
    }
};

boat.boatInfo(); // true, &#39;normal&#39;

var bigBoat = {
    size: &#39;big&#39;
};

bigBoat.boatInfo = boat.boatInfo;
bigBoat.boatInfo(); // false, &#39;big&#39;</code></pre><p>上面这段代码里，<code>this</code>本身是指向boat的，但是当我们创建一个新的对象，然后把<code>boat.boatInfo()</code>的方法赋给了它。然后我们调用<code>bigBoat.boatInfo()</code>,发现<code>this</code>不等于<code>boat</code>,<code>this.size</code>的值为big，<code>this</code>的指向改变了</p>
<blockquote>
<p>The first thing you must realise is that the value of this inside any function is never static, it is always determined every time you call a function, but before the function actually executes it’s code. The value of this inside a function is actually provided by the parent scope in which the function was called, and more importantly, how the actual function syntax was written.（<del>忘记哪本书上的了</del>）</p>
</blockquote>
<p>上面的意思大概就是，在任何函数中，<code>this</code>的指向都不是静态的(static)；它总是在你调用一个函数，但尚未执行函数内部代码前被指定；(查看参考链接中的执行环境的文章，这个阶段，实际就是初始化变量对象，在初始化变量对象的时候，确定了this的指向)实际上，this是被调用的函数的父作用域提供的，比如：<br>有一个巧妙的方法，当一个函数被调用时，应该立马看该作用域<code>()</code>左边的部分</p>
<ul>
<li><p>如果<code>()</code>左边是一个引用(reference),那么，函数的<code>this</code>指向的就是这个引用所属的对象</p>
</li>
<li><p>否则<code>this</code>指向的就是全局对象(window|global)</p>
<br />

</li>
</ul>
<p>我们来看一个简单的例子:</p>
<pre><code>function bar() {
    alert(this);
}
bar(); 
// 这里，this指向的是全局对象。我们先看()的左边，是bar,
// bar的左边是function，而function属于全局对象，所以this指向的就是全局对象

var foo = {
    baz: function() {
        alert(this);
    }
}
foo.baz(); 
// 这里,this指向的是foo,先看()左边是baz，baz是属于foo，所以baz里的this指向的就是foo</code></pre><br />

<p>我们再来看几个复杂的例子:</p>
<pre><code>var foo = {
    baz: function() {
        alert(this);
    }
}
foo.baz(); //这里this指向foo，因为()的左边是baz，而baz属于foo

var anotherBaz = foo.baz;
anotherBaz(); 
// 这里this指向全局对象，因为()左边是anotherBaz，znotherBaz（）是一个函数,函数属于全局对象</code></pre><pre><code>var anum = 0;

var foo = {
    anum: 10,
    baz: {
        anum: 20,
        bar: function() {
            console.log(this.anum);
        }
    }
}
foo.baz.bar(); // 20，因为()左边是bar，bar属于foo.baz，所以this就是foo.baz
,this.anum = foo.baz.anum = 20

var hello = foo.baz.bar;
hello(); // ()左边是hello，hello是一个函数，属于全局对象，所以this指向全局对
象，this.anum = window.anum = 0</code></pre><pre><code>const obj = {
  name: &#39;spike&#39;,
  friends: [&#39;deer&#39;, &#39;cat&#39;],
  loop: function() {
    this.friends.forEach( // ()左边是loop，而loop属于obj，所以这里的this指向obj
      function( friend ) {
        console.log(`${this.name} knows ${friend}`);
        console.log(this === global); // 在node.js环境下，全局对象为global
      }
    )
  }
}

obj.loop();
/*  可以看到，在forEach中的this并不是期待的那样指向obj，而是指向全局对象了  
**  也可以用上面提到的，还是看`()`左边，在forEach中，`()`左边是function，
**  function属于loop()，也是一个函数，而不是一个引用, 所以this指向的就是全局对
**  象
** 
**  所以这里的this.friends就是obj.friends this.name就是undfined
**
**  输出 
**  $ node test
**  undefined knows dear
**  true
**  undefined knows cat
*/  true</code></pre><br />

<p><strong>在构造函数里的this指向</strong>:<br>当使用<code>new</code>关键字去执行构造函数时，构造函数中的<code>this</code>指向的的就是新建的那个对象实例</p>
<pre><code>  var savedThis;
    function Constr() {
        // 保存构造函数中的this
        savedThis = this;
    }
    // 通过new关键字执行构造函数
    var inst = new Constr();

    // 构造函数中的this指向的就是新创建的对象实例inst
    console.log(savedThis === inst); // true</code></pre><p>如果你没有用<code>new</code>关键字去执行构造函数，那么就要分析函数被调用时所属的作用域了</p>
<pre><code>  function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    var p = Point(7, 5); // 没有用new关键字去执行构造函数！

    console.log(p === undefined); // 没有用new，所以构造函数没有返回一个实例 
    对象，所以 p === undefined

    // 没有用new关键字，Point(7,5);就只是把函数执行了一遍
    // ()左边是Point，属于全局对象，所以this指向全局对象
    console.log(x); // 7
    console.log(y); // 5</code></pre><br />

<p><strong>在事件处理器(event handler)中this的指向</strong>:</p>
<pre><code>&lt;div id=&quot;test&quot;&gt;I am an element with id #test&lt;/div&gt;

function doAlert() { 
    alert(this.innerHTML); 
} 

doAlert(); // undefined 
// doAlert()属于全局对象

var myElem = document.getElementById(&#39;test&#39;); 
myElem.onclick = doAlert; 

alert(myElem.onclick === doAlert); // true 
myElem.onclick(); // I am an element
// ()左边是onclick也就是doAlert,属于myElem,所以this指向myElem</code></pre><p>那个元素触发事件，this就指向那个元素</p>
<br />

<p><strong>总结</strong>:<br>  以上，对于函数中的<code>this</code>，通过查看<code>()</code>左边所属的对象去确定，真的很好用.<br>而实质上，<code>this</code>是在创建函数的执行环境时，在创建阶段确定的，因此，弄透执行环境，去思考执行环境创建阶段的<code>this</code>的指向，<code>this</code>的指向就不会弄错了.</p>
<h1 id="3-原型继承-prototypal-inheritance-的原理"><a href="#3-原型继承-prototypal-inheritance-的原理" class="headerlink" title="3-原型继承 (prototypal inheritance) 的原理"></a>3-原型继承 (prototypal inheritance) 的原理</h1><p>在 JavaScript 中，每个函数都有一个 prototype 属性，当这个函数被用作构造函数来创建实例时，这个函数的 prototype 属性值会被作为原型赋值给所有对象实例，也就是说，所有实例的原型引用的是函数的 prototype 属性<br>为了证明这一点,我们可以在 Chrome 控制台输入：</p>
<pre><code>function Person() {
}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true</code></pre><p>我们可以得到如下的关系图：<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1fg89af3vdaj30g0082t8x.jpg" alt="prototypal inheritance"></p>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<p>原型指向实例倒是没有，因为一个构造函数可以生成多个实例。但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数<br>让我们来验证一下：</p>
<pre><code>function Person() {
}
console.log(Person === Person.prototype.constructor); // true</code></pre><p>所以再更新下关系图：<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1fg89eran0aj30g4082dg5.jpg" alt="prototypal inheritance"></p>
<p><strong>属性查找</strong><br>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部（也就是 Object.prototype），如果仍然没有找到指定的属性，就会返回 undefined。</p>
<p>举个例子：</p>
<pre><code>function Person() {
}
Person.prototype.name = &#39;Kevin&#39;;
var person = new Person();
person.name = &#39;Daisy&#39;;
console.log(person.name) // Daisy
delete person.name;
console.log(person.name) // Kevin</code></pre><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin</p>
<p><strong>原型链</strong><br>同样，<code>person.prototype</code> 对象也有<code>__proto__</code>属性，它指向创建它的函数对象（Object）的 prototype</p>
<p><code>console.log(person.prototype.__proto__ === Object.prototype) //true</code></p>
<p>继续，<code>Object.prototype</code>对象也有 <code>__proto__</code>属性，但它比较特殊，为null</p>
<p><code>console.log(Object.prototype.__proto__) //null</code></p>
<p>我们把这个由 <code>__proto__</code> 串起来的直到 <code>Object.prototype.__proto__</code>为null的链叫做原型链</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1fg89mi2hv1j30ge0elt9d.jpg" alt="prototypal inheritancd"></p>
<p><strong>补充</strong><br>最后，补充两点可能不会注意的地方：</p>
<ul>
<li><strong>constructor</strong><pre><code>function Person() {
}
var person = new Person();
console.log(person.constructor === Person); // true</code></pre>当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</li>
</ul>
<p><code>person.constructor === Person.prototype.constructor</code></p>
<ul>
<li><strong><strong>proto</strong></strong></li>
</ul>
<p>其次是<code>__proto__</code>，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中。实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用<code>obj.__proto__</code>时，可以理解成返回了 Object.getPrototypeOf(obj)</p>
<h1 id="4-AMD-vs-CommonJS？"><a href="#4-AMD-vs-CommonJS？" class="headerlink" title="4-AMD vs. CommonJS？"></a>4-AMD vs. CommonJS？</h1><p>AMD和CommonJS是JavaScript的两种模块规范</p>
<p>在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载，然后，就可以调用模块提供的方法：</p>
<pre><code>var math = require(&#39;math&#39;);
math.add(2,3); // 5</code></pre><p>有了服务器端模块以后，很自然地，大家就想要客户端模块；而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行.</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境；还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<pre><code>var math = require(&#39;math&#39;);
math.add(2, 3);</code></pre><p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间；但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）；这就是AMD规范诞生的背景</p>
<p><strong>ADM</strong><br><strong>AMD</strong>是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”<br>它采用异步方式加载模块，模块的加载不影响它后面语句的运行;所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<br><code>require([module], callback);</code></p>
<ul>
<li>第一个参数<code>[module]</code>，是一个数组，里面的成员就是要加载的模块；</li>
<li>第二个参数callback，则是加载成功之后的回调函数<br>如果将前面的代码改写成AMD形式，就是下面这样：<pre><code>　require([&#39;math&#39;], function (math) {
　　　　math.add(2, 3);
　　});</code></pre>math.add()与math模块加载不是同步的，浏览器不会发生假死<br>所以很显然，AMD比较适合浏览器环境</li>
</ul>
<h1 id="5-请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式"><a href="#5-请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式" class="headerlink" title="5-请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式):"></a>5-请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式):</h1><p><code>function foo(){ }();</code></p>
<p>以function关键字开头的语句会被解析为函数声明，而函数声明是不允许直接运行的<br>原因：</p>
<ul>
<li>js”预编译”的特点:js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.</li>
<li>当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();故会报错</li>
<li>只有当解析器把这句话解析为函数表达式，才能够直接运行</li>
</ul>
<p>例如：</p>
<pre><code>(function foo(){
    // code..
})()</code></pre><h1 id="6-描述以下变量的区别：null，undefined-或-undeclared？该如何检测它们？"><a href="#6-描述以下变量的区别：null，undefined-或-undeclared？该如何检测它们？" class="headerlink" title="6-描述以下变量的区别：null，undefined 或 undeclared？该如何检测它们？"></a>6-描述以下变量的区别：<code>null</code>，<code>undefined</code> 或 <code>undeclared</code>？该如何检测它们？</h1><ul>
<li>undefined 为为定义</li>
<li>null 为一个空值</li>
</ul>
<p>typeof undefined 返回 undefined<br>typeof null 返回 object</p>
<h1 id="7-什么是闭包-closure-，如何使用它，为什么要使用它？"><a href="#7-什么是闭包-closure-，如何使用它，为什么要使用它？" class="headerlink" title="7-什么是闭包 (closure)，如何使用它，为什么要使用它？"></a>7-什么是闭包 (closure)，如何使用它，为什么要使用它？</h1><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”，就是能够读取其他函数内部变量的函数</p>
<p>闭包可以让这些变量的值始终保持在内存中，让我们可以读取函数内部的变量;所以在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<p>闭包的特性：<br>1.函数内再嵌套函数<br>2.内部函数可以引用外层的参数和变量<br>3.参数和变量不会被垃圾回收机制回收</p>
<h1 id="8-请举出一个匿名函数的典型用例？"><a href="#8-请举出一个匿名函数的典型用例？" class="headerlink" title="8-请举出一个匿名函数的典型用例？"></a>8-请举出一个匿名函数的典型用例？</h1><p>匿名函数：就是没有函数名的函数，自执行匿名函数</p>
<ul>
<li>匿名函数的基本形式为（function（）{…}）（）;</li>
<li>前面的括号包含函数体，后面的括号就是给匿名函数传递参数并立即执行之</li>
<li>匿名函数的作用是用于闭包和避免变量的污染以及函数名的冲突</li>
</ul>
<p>举例说明：</p>
<pre><code>function func() {
  return function() {

  }
}

const func = function(){}

(function(){

})()</code></pre><p>用途：<br>        匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以嵌套命名空间，以减少变量的使用</p>
<p>作用域链的机制导致一个问题，<strong>在循环中里的匿名函数取得的任何变量都是最后一个值</strong></p>
<h1 id="9-你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#9-你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="9-你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>9-你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h1><p>模块模式，一个IIFE就算是一个模块，互相之间不影响</p>
<pre><code>var jspy = (function() {
  var _count = 0;

  var incrementCount = function() {
    _count++;
  }

  var getCount = function() {
    return _count;
  }
  return {
    incrementCount: incrementCount,
    getCount: getCount
  };
})();  </code></pre><h1 id="10-请指出-JavaScript-宿主对象-host-objects-和原生对象-native-objects-的区别？"><a href="#10-请指出-JavaScript-宿主对象-host-objects-和原生对象-native-objects-的区别？" class="headerlink" title="10-请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？"></a>10-请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？</h1><ol>
<li><p><strong>原生对象：</strong></p>
<ul>
<li>独立于宿主环境的ECMAScript实现提供的对象</li>
<li>与宿主无关，在javascript（远景浏览器）、nodejs（node平台）、jscript（ie浏览器）、typescript（微软平台）等等中均有这些对象</li>
<li>简单来说，本地对象就是 ECMA-262 定义的类（引用类型），在运行过程中动态创建的对象，需要new<br />
</li>
</ul>
</li>
<li><p><strong>内置对象：</strong> </p>
<ul>
<li><p>由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现，即在引擎初始化阶段就被创建好的对象；这意味着开发者不必明确实例化内置对象，它已被实例化了 </p>
</li>
<li><p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）如此就可以理解了，内置对象是本地对象的一种</p>
<br />
</li>
</ul>
</li>
<li><p><strong>宿主对象：</strong></p>
<ul>
<li><p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”</p>
</li>
<li><p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义类对象，ECMAScript官方未定义的对象都属于宿主对象,所有非本地对象都是宿主对象</p>
</li>
<li><p>宿主提供对象原理==&gt;由宿主框架通过某种机制注册到ECscript引擎中的对象，如宿主浏览器（以远景为参考）会向ECscript注入window对象，构建其实现javascript。所有的BOM和DOM都是宿主对象。</p>
</li>
<li><p>说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象</p>
</li>
</ul>
</li>
</ol>
<h1 id="11-请指出以下代码的区别：function-Person-、var-person-Person-、var-person-new-Person"><a href="#11-请指出以下代码的区别：function-Person-、var-person-Person-、var-person-new-Person" class="headerlink" title="11-请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()"></a>11-请指出以下代码的区别：<code>function Person(){}</code>、<code>var person = Person()</code>、<code>var person = new Person()</code></h1><ul>
<li>第一个是定义了一个函数Person</li>
<li>第二个是把Person当普通函数执行，并把返回值赋值给person。</li>
<li>第三个是当做构造函数，通过new关键字创建一个实例对象，赋值给person </li>
</ul>
<h1 id="12-call-和-apply-的区别是什么"><a href="#12-call-和-apply-的区别是什么" class="headerlink" title="12-.call 和 .apply 的区别是什么"></a>12-<code>.call</code> 和 <code>.apply</code> 的区别是什么</h1><p>.call和.apply存在的意义：<strong>改变函数执行时的上下文</strong>，再具体一点就是<strong>改变函数运行时的this指向</strong>.</p>
<p>ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已.</p>
<ol>
<li><strong><code>apply( )</code></strong><br>apply 方法传入两个参数：<br>一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组.<pre><code>var obj = {
 name : &#39;linxin&#39;
}
function func(firstName, lastName){
 console.log(firstName + &#39; &#39; + this.name + &#39; &#39; + lastName);
}
func.apply(obj, [&#39;A&#39;, &#39;B&#39;]);    // A linxin B</code></pre></li>
</ol>
<p>可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素.</p>
<ol start="2">
<li><strong><code>call( )</code></strong><br>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组.<pre><code>var obj = {
 name: &#39;linxin&#39;
}
function func(firstName, lastName) {
 console.log(firstName + &#39; &#39; + this.name + &#39; &#39; + lastName);
}
func.call(obj, &#39;C&#39;, &#39;D&#39;);       // C linxin D</code></pre></li>
</ol>
<p>对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中</p>
<p>对于什么时候该用什么方法，其实不用纠结；如果你的参数本来就存在一个数组中，那自然就用 apply；如果参数比较散乱相互之间没什么关联，就用 call.</p>
<ol start="3">
<li><strong><code>apply</code> 和 <code>call</code> 的用法</strong></li>
</ol>
<ul>
<li><ol>
<li>改变 this 指向</li>
</ol>
</li>
</ul>
<pre><code>var obj = {
    name: &#39;linxin&#39;
}
function func() {
    console.log(this.name);
}
func.call(obj);       // linxin</code></pre><p>我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象；此处 func 函数里其实相当于：</p>
<pre><code>function func() {
    console.log(obj.name);
}</code></pre><ul>
<li><ol start="2">
<li>借用别的对象的方法</li>
</ol>
</li>
</ul>
<p>先看例子</p>
<pre><code>var Person1  = function () {
    this.name = &#39;linxin&#39;;
}
var Person2 = function () {
    this.getname = function () {
        console.log(this.name);
    }
    Person1.call(this);
}
var person = new Person2();
person.getname();       // linxin</code></pre><p>从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name.<br>因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法.</p>
<ul>
<li><ol start="3">
<li>调用函数</li>
</ol>
</li>
</ul>
<p>apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数</p>
<pre><code>function func() {
    console.log(&#39;linxin&#39;);
}
func.call();            // linxin</code></pre><ol start="4">
<li><strong>call 和 bind 的区别</strong></li>
</ol>
<p>在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容.<br>它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数.</p>
<p>它们之间的区别有以下两点:</p>
<ul>
<li><ol>
<li>bind 返回值是函数<pre><code>var obj = {
name: &#39;linxin&#39;
}
function func() {
console.log(this.name);
}
var func1 = func.bind(obj);
func1();                        // linxin</code></pre>bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数；而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window.</li>
</ol>
</li>
<li><ol start="2">
<li>参数的使用</li>
</ol>
</li>
</ul>
<pre><code>function func(a, b, c) {
    console.log(a, b, c);
}
var func1 = func.bind(null,&#39;linxin&#39;);
func(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);            // A B C
func1(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);           // linxin A B
func1(&#39;B&#39;, &#39;C&#39;);                // linxin B C
func.call(null, &#39;linxin&#39;);      // linxin undefined undefined</code></pre><p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排.</p>
<p>在低版本浏览器没有 bind 方法，我们也可以自己实现一个:</p>
<pre><code>if (!Function.prototype.bind) {
        Function.prototype.bind = function () {
            var self = this,                        // 保存原函数
                context = [].shift.call(arguments), // 保存需要绑定的this上下文
                args = [].slice.call(arguments);    // 剩余的参数转为数组
            return function () {                    // 返回一个新函数
                self.apply(context,[].concat.call(args, [].slice.call(arguments)));
            }
        }
    }</code></pre><h1 id="13-解释-Function-prototype-bind？"><a href="#13-解释-Function-prototype-bind？" class="headerlink" title="13-解释 Function.prototype.bind？"></a>13-解释 Function.prototype.bind？</h1><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用.</p>
<pre><code>const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42</code></pre><h1 id="14-在什么时候你会使用-document-write-？"><a href="#14-在什么时候你会使用-document-write-？" class="headerlink" title="14-在什么时候你会使用 document.write()？"></a>14-在什么时候你会使用 <code>document.write()</code>？</h1><p>DOM方法，可向文档写入 HTML 表达式或 JavaScript 代码</p>
<ul>
<li><p>加载需要配合JS脚本使用的外部CSS文件<br>将所有需要用到JS的样式都放到这个外部样式表中，如果浏览器不禁用JS，那么该样式<br>表就会被顺利加载，否则页面就不会使用该样式</p>
<pre><code>&lt;scirpt&gt;
document.write(&#39;&lt;link  rel=&quot;stylesheet&quot; href=&quot;style_neads_js.css&quot;&gt;&#39;);
&lt;/script&gt;</code></pre></li>
<li><p>在新的窗口中写入新的页面数据时<br>由于document.write会重写整个页面，异步调用会影响本页面的文档，如果在新窗口空<br>白页调用，就没影响了;新开一个窗口，把本页面取到的数据在新窗口展示:</p>
<pre><code>document.open();
document.write(&#39;anthing&#39;)
document.close();</code></pre><p>由于带来的弊端较多，一般不建议使用<br>要对DOM进行操作时，还是应当使用安全且对DOM的友好的API方法，以避免不必要的问题出现.</p>
</li>
</ul>
<blockquote>
<p>注：<br>document.write是直接将内容写入页面的内容流，会导致页面全部重绘<br>innerHTML将内容写入某个DOM节点，不会导致页面全部重绘</p>
</blockquote>
<h1 id="15-请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别"><a href="#15-请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别" class="headerlink" title="15-请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别"></a>15-请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别</h1><p>特性检测是指检测浏览器是否支持某个给定特性的过程，该方法是浏览器检测的首选方法</p>
<p>特性检测的模式很简单：首先检查特性是否存在，如果存在，就使用该特性.因此，使用一个if语句即可实现，如下所示：</p>
<pre><code>if(navigator.geolocation){
  //user geolocation
}</code></pre><p>上面的这种方式令人困惑，也给代码增加了歧义性.现在应尽量避免使用truthy/falsey语句，而是选择使用typeof运算符，如下所示：</p>
<pre><code>if(typeof  navigator.geolocation!=&quot;undefined&quot;){
        //use geolocation
    }</code></pre><p>浏览器嗅探<br>在大多数情况下，首选使用特性检测方法.因为浏览器嗅探方法具有许多缺陷</p>
<ul>
<li>其中之一就是少数浏览器可能宣称自己是某主流浏览器，其实并不是那种浏览器类型</li>
<li>另外一个问题是浏览器嗅探依赖于浏览器的userAgent字符串(user-agent string)，该字符串用于标识浏览器，且浏览器制造商可以在不同的版本之间进行大幅度的修改。仅挡针对其有古怪行为的单个浏览器时，才使用浏览器嗅探技术</li>
</ul>
<blockquote>
<p>navigator对象的appName属性和userAgent属性在标识浏览器方面很有用</p>
<ul>
<li>appName属性将返回浏览器的模型，如对IE返回Microsoft Internet Explorer,对Firefox,Chrome和Safari返回Netscape</li>
<li>userAgent属性返回一个包含多段信息的字符串，如浏览器的版本，操作系统和浏览器模型.但是，这个属性的返回值因浏览器而异.例如，浏览器的版本被嵌入在该字符串的不同位置</li>
</ul>
</blockquote>
<h1 id="16-请尽可能详尽的解释-Ajax-的工作原理"><a href="#16-请尽可能详尽的解释-Ajax-的工作原理" class="headerlink" title="16-请尽可能详尽的解释 Ajax 的工作原理"></a>16-请尽可能详尽的解释 Ajax 的工作原理</h1><p>Ajax的工作原理相当于在用户和服务器之间加了一个<strong>中间层(AJAX引擎)</strong>,使用户操作与服务器响应异步化，而且并不是所有的用户请求都提交给服务器,像一些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求</p>
<p>Ajax其核心有<code>JavaScript、XMLHTTPRequest、DOM</code>对象组成:</p>
<ol>
<li>通过<code>XmlHttpRequest对象</code>来向服务器发异步请求</li>
<li>然后<code>xhr对象</code>提供了一系列属性，可以监听响应的情况</li>
<li>然后从服务器获得数据</li>
<li>再用JavaScript来操作DOM而更新页面</li>
</ol>
<h1 id="17-请解释变量声明提升-hoisting"><a href="#17-请解释变量声明提升-hoisting" class="headerlink" title="17-请解释变量声明提升 (hoisting)"></a>17-请解释变量声明提升 (hoisting)</h1><p>“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准,实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中</p>
<p>JavaScript在执行任何代码段之前，将函数声明放入内存中的优点之一是你可以在声明一个函数之前使用该函数，列如:</p>
<pre><code>/**
* 正确的方式：先声明函数，再调用函数 (最佳实践)
*/
function catName(name) {
    console.log(&quot;我的猫名叫 &quot; + name);
}

catName(&quot;Tigger&quot;);

/*
以上代码的执行结果是: &quot;我的猫名叫 Tigger&quot;
*/</code></pre><p>上面的代码片按照是你的正常思维（先声明，后调用）去书写的<br>现在我们来看看当我们在写这个函数之前调用这个函数会发生什么：</p>
<pre><code>/**
* 不推荐的方式：先调用函数，再声明函数 
*/

catName(&quot;Chloe&quot;);

function catName(name) {
    console.log(&quot;我的猫名叫 &quot; + name);
}

/*
代码执行的结果是: &quot;我的猫名叫 Chloe&quot;
*/</code></pre><p>即使我们在定义这个函数之前调用它，函数仍然可以工作，这是因为在JavaScript中<strong>执行上下文</strong>的工作方式造成的.<br>变量提升也适用于其他数据类型和变量，变量可以在声明之前进行初始化和使用，但是如果没有初始化，就不能使用它们.</p>
<blockquote>
<p>注： 函数和变量相比，函数会被优先提升，这意味着函数会被提升到更靠前的位置</p>
</blockquote>
<pre><code>num = 6;
num + 7;
var num;
/* 没有给出错误，只要声明了num */</code></pre><p><strong>JavaScript 仅提升声明，而不提升初始化</strong>，如果你先使用的变量，再声明并初始化它，变量的值将是 undefined，以下两个示例演示了相同的行为：</p>
<pre><code>var x = 1;                 // 声明 + 初始化 x
console.log(x + &quot; &quot; + y);  // &#39;1 undefined&#39;
var y = 2;                 // 声明 + 初始化 y


//上面的代码和下面的代码是一样的 
var x = 1;                 // 声明 + 初始化 x
var y;                     //声明 y
console.log(x + &quot; &quot; + y);  //y 是未定义的
y = 2;                     // 初始化  y </code></pre><h1 id="18-“attribute”-和-“property”-的区别是什么？"><a href="#18-“attribute”-和-“property”-的区别是什么？" class="headerlink" title="18-“attribute” 和 “property” 的区别是什么？"></a>18-“attribute” 和 “property” 的区别是什么？</h1><ul>
<li>Attribute是原属性</li>
<li>Property是通过方法处理过得到的属性</li>
</ul>
<h1 id="19-为什么扩展-JavaScript-内置对象不是好的做法？"><a href="#19-为什么扩展-JavaScript-内置对象不是好的做法？" class="headerlink" title="19-为什么扩展 JavaScript 内置对象不是好的做法？"></a>19-为什么扩展 JavaScript 内置对象不是好的做法？</h1><ul>
<li><strong>扩展对象时，会更改其行为.</strong><br>更改只由您自己的代码使用的对象的行为是可以的，但是，当您更改其他代码也使用的某个代码的行为时，可能会破坏其他代码,当它在javascript中向对象和数组类添加方法时，由于javascript的工作方式，破坏某些东西的风险非常高</li>
</ul>
<h1 id="20-请指出-document-load-和-document-DOMContentLoaded-两个事件的区别"><a href="#20-请指出-document-load-和-document-DOMContentLoaded-两个事件的区别" class="headerlink" title="20-请指出 document load 和 document DOMContentLoaded 两个事件的区别"></a>20-请指出 document load 和 document DOMContentLoaded 两个事件的区别</h1><p>触发的时机不一样，先触发DOMContentLoaded事件（DOM树生成完成），后触发load事件（页面加载完成）</p>
<ul>
<li>DOMContentLoaded: DOM解析完成即触发此事件，不等待styles, images等资源的加载</li>
<li>load：依赖的资源也已加载完成</li>
</ul>
<p>DOM文档加载的步骤为:</p>
<pre><code>解析HTML结构
加载外部脚本和样式表文件
解析并执行脚本代码
DOM树构建完成  //DOMContentLoaded
加载图片等外部文件
页面加载完毕 //load</code></pre><p>用原生js可以这么写:</p>
<pre><code>// 不兼容老的浏览器，兼容写法见[jQuery中ready与load事件](http://www.imooc.com/
code/3253)，或用jQuery


document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
   // ...代码...
}, false);


window.addEventListener(&quot;load&quot;, function() {
    // ...代码...
}, false);</code></pre><p>用jQuery这么写:</p>
<pre><code>// DOMContentLoaded
$(document).ready(function() {
    // ...代码...
});

//load
$(document).load(function() {
    // ...代码...
});</code></pre><h1 id="21-和-有什么不同？"><a href="#21-和-有什么不同？" class="headerlink" title="21-== 和 === 有什么不同？"></a>21-== 和 === 有什么不同？</h1><p><strong>“===”叫做严格运算符，”==”叫做相等运算符</strong></p>
<ul>
<li><strong>严格运算符的运算规则如下:</strong></li>
</ul>
<p>(1)不同类型值<br>如果两个值的类型不同，直接返回false</p>
<p>(2)同一类的原始类型值<br>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false</p>
<p>(3)同一类的复合类型值<br>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象</p>
<p>(4)undefined和null<br>undefined 和 null 不严格相等,与自身严格相等</p>
<ul>
<li><strong>相等运算符在比较相同类型的数据时，与严格相等运算符完全一样:</strong></li>
</ul>
<p>(1)原始类型的值<br>原始类型的数据会转换成数值类型再进行比较</p>
<p>(2)对象与原始类型值比较<br>对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较</p>
<p>(3)undefined和null<br>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true</p>
<p>(4)相等运算符的缺点<br>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</p>
<p><img src="https://pic1.zhimg.com/80/b922270259dece707ef6c6a50259a406_hd.jpg" alt="img"></p>
<ul>
<li>红色：===</li>
<li>橙色：==</li>
<li>黄色：&lt;= 和 &gt;= 同时成立，== 不成立</li>
<li>蓝色：只有 &gt;=</li>
<li>绿色：只有 &lt;=</li>
</ul>
<h1 id="22-请解释-JavaScript-的同源策略-same-origin-policy"><a href="#22-请解释-JavaScript-的同源策略-same-origin-policy" class="headerlink" title="22-请解释 JavaScript 的同源策略 (same-origin policy)"></a>22-请解释 JavaScript 的同源策略 (same-origin policy)</h1><p>所谓”同源”指的是”三个相同”:</p>
<ol>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ol>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据<br>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制:<br>（1） Cookie、LocalStorage 和 IndexDB 无法读取<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送</p>
<p><strong>解决同源的办法：</strong></p>
<ol>
<li>跨文档通信 API（Cross-document messaging）</li>
</ol>
<p>这个API为window对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源</p>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了，postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即<code>&quot;协议 + 域名 + 端口&quot;</code>，也可以设为<code>*</code>，表示不限制域名，向所有窗口发送</p>
<ol start="2">
<li>AJAX</li>
</ol>
<p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错，除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制:</p>
<hr>
<ul>
<li>| JSONP</li>
<li>| WebSocket</li>
<li>| CORS</li>
</ul>
<hr>
<ol start="3">
<li><p>document.domain 跨域</p>
</li>
<li><p>图像 Ping 跨域</p>
</li>
<li><p>window.name 跨域</p>
</li>
<li><p>location.hash 跨域</p>
</li>
</ol>
<h1 id="23-如何实现下列代码"><a href="#23-如何实现下列代码" class="headerlink" title="23-如何实现下列代码"></a>23-如何实现下列代码</h1><p><strong><code>[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]</code></strong></p>
<ol>
<li><pre><code>Array.prototype.duplicator = function(){
　　var l = this.length,i;
　　for(i=0;i&lt;l;i++){
　　　this.push(this[i])　
}</code></pre></li>
<li><pre><code>Array.prototype.duplicator = function(){
 var s = this.concat(this);        
 return s;
}</code></pre></li>
</ol>
<h1 id="24-什么是三元表达式-Ternary-expression-？"><a href="#24-什么是三元表达式-Ternary-expression-？" class="headerlink" title="24-什么是三元表达式 (Ternary expression)？"></a>24-什么是三元表达式 (Ternary expression)？</h1><p>三元表达式即使用三元运算符的三个操作数：</p>
<pre><code>test ? num1 : num2</code></pre><p>如果test为true，则结果取num1，否则取num2</p>
<h1 id="25-什么是-“use-strict”-使用它的好处和坏处分别是什么？"><a href="#25-什么是-“use-strict”-使用它的好处和坏处分别是什么？" class="headerlink" title="25-什么是 “use strict” ? 使用它的好处和坏处分别是什么？"></a>25-什么是 “use strict” ? 使用它的好处和坏处分别是什么？</h1><p>use strict(严格模式)是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法，这种模式使得Javascript在更严格的条件下运行</p>
<ol>
<li><p><strong>针对单个函数</strong><br>将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行:</p>
<pre><code>　　function strict(){
　　　　&quot;use strict&quot;;
　　　　return &quot;这是严格模式。&quot;;
　　}

　　function notStrict() {
　　　　return &quot;这是正常模式。&quot;;
　　}</code></pre></li>
<li><p><strong>针对整个脚本文件</strong><br>将整个脚本文件放在一个立即执行的匿名函数之中:</p>
<pre><code>　　(function (){
　　　　&quot;use strict&quot;;
　　　　// some code here
　　 })();</code></pre></li>
</ol>
<ol start="3">
<li><p><strong>严格模式对Javascript的语法和行为，都做了一些改变：</strong><br><strong>3.1 全局变量显式声明</strong><br>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量<br>严格模式禁止这种用法，全局变量必须显式声明:</p>
<pre><code>&quot;use strict&quot;;

　　v = 1; // 报错，v未声明

　　for(i = 0; i &lt; 2; i++) { // 报错，i未声明
　　}</code></pre><p>因此，严格模式下，变量都必须先用var命令声明，然后再使用</p>
<p><strong>3.2 静态绑定</strong></p>
<ul>
<li><p>Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的</p>
</li>
<li><p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定；也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外</p>
</li>
</ul>
<p>具体来说，涉及以下几个方面:<br> （1）禁止使用with语句<br>因为with语句无法在编译时就确定，属性到底归属哪个对象:</p>
<pre><code>　　&quot;use strict&quot;;

　　var v = 1;
　　with (o){ // 语法错误
　　　　v = 2;
　　}</code></pre><p> （2）创设eval作用域<br>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域<br>严格模式创设了第三种作用域：eval作用域</p>
<p>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域<br>严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部</p>
<pre><code>　&quot;use strict&quot;;

　　var x = 2;
　　 console.info(eval(&quot;var x = 5; x&quot;)); // 5
　　console.info(x); // 2</code></pre><p><strong>3.3 增强的安全措施</strong><br> （1）禁止this关键字指向全局对象</p>
<pre><code>　　function f(){
　　　　return !this;
　　}
　　// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false

　　function f(){
　　　　&quot;use strict&quot;;
　　　　return !this;
　　}
　　// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</code></pre><p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错</p>
<pre><code>　　function f(){

　　　　&quot;use strict&quot;;
　　　　this.a = 1;
　　};

　　f();// 报错，this未定义</code></pre><p> （2）禁止在函数内部遍历调用栈</p>
<pre><code>　　function f1(){
　　　　&quot;use strict&quot;;

　　　　f1.caller; // 报错
　　　　f1.arguments; // 报错
　　}
　　f1();</code></pre><p><strong>3.4 禁止删除变量</strong><br> 严格模式下无法删除变量，只有configurable设置为true的对象属性，才能被删除</p>
<pre><code>　　&quot;use strict&quot;;

　　var x;
　　delete x; // 语法错误
　　var o = Object.create(null, {&#39;x&#39;: {
　　　　　　value: 1,
　　　　　　configurable: true
　　}});

　　delete o.x; // 删除成功</code></pre><p><strong>3.5 显式报错</strong><br>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败<br>严格模式下，将报错:</p>
<pre><code>　　&quot;use strict&quot;;

　　var o = {};
　　Object.defineProperty(o, &quot;v&quot;, { value: 1, writable: false });
　　o.v = 2; // 报错</code></pre><p>严格模式下，对一个使用getter方法读取的属性进行赋值，会报错:</p>
<pre><code>　　&quot;use strict&quot;;

　　var o = {
　　　　get v() { return 1; }
　　};
　　  o.v = 2; // 报错</code></pre><p>严格模式下，对禁止扩展的对象添加新属性，会报错:</p>
<pre><code>　　&quot;use strict&quot;;

　　var o = {};
　　Object.preventExtensions(o);
　　o.v = 1; // 报错</code></pre><p>严格模式下，删除一个不可删除的属性，会报错:</p>
<pre><code>　　&quot;use strict&quot;;

　　delete Object.prototype; // 报错</code></pre><p><strong>3.6 重名错误</strong><br>严格模式新增了一些语法错误:<br> （1）对象不能有重名的属性<br>正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值<br>严格模式下，这属于语法错误:</p>
<pre><code>　　&quot;use strict&quot;;

　　var o = {
　　　　p: 1,
　　　　p: 2
　　}; // 语法错误</code></pre><p> （2）函数不能有重名的参数<br>正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取<br>严格模式下，这属于语法错误:</p>
<pre><code>　　&quot;use strict&quot;;

　　function f(a, a, b) { // 语法错误
　　　　return ;
　　}</code></pre><p><strong>3.7 禁止八进制表示法</strong><br>正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64<br>严格模式禁止这种表示法，整数第一位为0，将报错:</p>
<pre><code>　　&quot;use strict&quot;;

　　var n = 0100; // 语法错误</code></pre><p><strong>3.8 arguments对象的限制</strong><br>arguments是函数的参数对象，严格模式对它的使用做了限制:<br> （1）不允许对arguments赋值</p>
<pre><code>　　&quot;use strict&quot;;

　　arguments++; // 语法错误
　　var obj = { set p(arguments) { } }; // 语法错误
　　try { } catch (arguments) { } // 语法错误
　　function arguments() { } // 语法错误
　　var f = new Function(&quot;arguments&quot;, &quot;&#39;use strict&#39;; return 17;&quot;); // 语法错误</code></pre><p> （2）arguments不再追踪参数的变化</p>
<pre><code>　　function f(a) {
　　　　a = 2;
　　　　return [a, arguments[0]];
　　}

　　f(1); // 正常模式为[2,2]
　　
 function f(a) {
　　　　&quot;use strict&quot;;

　　　　a = 2;
　　　　return [a, arguments[0]];
　　}
　　f(1); // 严格模式为[2,1]</code></pre><p> （3）禁止使用arguments.callee<br>这意味着，你无法在匿名函数内部调用自身了:</p>
<pre><code>　　&quot;use strict&quot;;

　　var f = function() { return arguments.callee; };
　　f(); // 报错</code></pre><p><strong>3.9 函数必须声明在顶层</strong><br>将来Javascript的新版本会引入”块级作用域”，为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数，也就是说，不允许在非函数的代码块内声明函数:</p>
<pre><code>　　&quot;use strict&quot;;

　　if (true) {
　　　　function f() { } // 语法错误
　　}

　　for (var i = 0; i &lt; 5; i++) {
　　　　function f2() { } // 语法错误
　　}</code></pre><p><strong>3.10 保留字</strong><br>为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield使用这些词作为变量名将会报错:</p>
<pre><code>　　function package(protected) { // 语法错误
　　　　&quot;use strict&quot;;

　　　　var implements; // 语法错误
　　}</code></pre><p>此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的</p>
</li>
</ol>
<ol start="4">
<li><strong>use strict的优点：</strong><ul>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全</li>
<li>提高编译器效率，增加运行速度</li>
<li>为未来新版本的Javascript做好铺垫</li>
</ul>
</li>
</ol>
<p>注：经过测试 IE6,7,8,9 均不支持严格模式</p>
<ol start="5">
<li><strong>use strict的缺点：</strong><br>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有；这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li>
</ol>
<h1 id="26-请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”"><a href="#26-请实现一个遍历至-100-的-for-loop-循环，在能被-3-整除时输出-“fizz”，在能被-5-整除时输出-“buzz”，在能同时被-3-和-5-整除时输出-“fizzbuzz”" class="headerlink" title="26-请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”"></a>26-请实现一个遍历至 <code>100</code> 的 for loop 循环，在能被 <code>3</code> 整除时输出 <strong>“fizz”</strong>，在能被 <code>5</code> 整除时输出 <strong>“buzz”</strong>，在能同时被 <code>3</code> 和 <code>5</code> 整除时输出 <strong>“fizzbuzz”</strong></h1><pre><code>for (let i = 0; i &lt;= 100; i++) {
     if (i % 15 == 0) {
      console.log(&#39;fizzbuzz&#39;)
     }else if (i % 3 == 0) {
          console.log(&#39;fizz&#39;)
         }else if (i % 5 == 0) {
              console.log(&#39;buzz&#39;)
     }else {
         consoloe.log(i)
     }
}</code></pre><h1 id="27-为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？"><a href="#27-为何通常会认为保留网站现有的全局作用域-global-scope-不去改变它，是较好的选择？" class="headerlink" title="27-为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？"></a>27-为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？</h1><p>  <strong>尽量少在全局作用域定义变量，目的:</strong></p>
<ol>
<li>减少名称冲突</li>
<li>利于模块化</li>
</ol>
<p>比如<code>alert</code>就是一个全局的变量，如果你有下面的代码就会把它覆盖了：</p>
<pre><code>alert=function(){
   //code
}</code></pre><h1 id="28-为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"><a href="#28-为何你会使用-load-之类的事件-event-？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？" class="headerlink" title="28-为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？"></a>28-为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？</h1><h1 id="29-请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly"><a href="#29-请解释什么是单页应用-single-page-app-以及如何使其对搜索引擎友好-SEO-friendly" class="headerlink" title="29-请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)"></a>29-请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)</h1><p><strong>单页应用</strong>（single-page application，缩写<strong>SPA</strong>）SPA是一种网络应用程序(WebApp)模型；在这个模型中，通过动态地重写页面的部分与用户交互，避免了过多的数据交换，而非传统的从服务器重新加载整个新页面，这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序.<br>在单页应用中，所有必要的代码HTML、JavaScript和CSS都通过单个页面的加载而检索,或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面</p>
<p><strong>1. SPA的优点</strong><br>基本上前后端分离的优点它都有，另外还有以下的一些优点:<br>  (1)页面之间的切换非常快<br>  (2)一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染）<br>  (3)后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等</p>
<p><strong>2. SPA的缺点</strong><br>  (1)首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面<br>  (2)不利于SEO</p>
<p><strong>SEO（Search Engine Optimization）</strong>：是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名</p>
<p>SPA不利于SEO，因为就目前而言，部分搜索引擎如Google、bing等，它们的爬虫虽然已经支持执行JS甚至是通过AJAX获取数据了，但是对于异步数据的支持也还不足；并且有一些搜索引擎还不支持执行JS和通过AJAX获取数据，那就更不用提SEO了</p>
<p><strong>3. SPA如何对SEO友好</strong></p>
<ul>
<li><p>使用SSR等后端渲染技术</p>
</li>
<li><p>对当前SPA进行SEO优化:<br>(1)注重TDK的写法<br>既然页面单一，那么就更需要注重网站标题、关键词和描述的写法。标题上来说，要简单明确，包含主要关键词，一句话能概括全文;描述上来讲，一句话活一小段文字提炼出文章的精髓，内容比标题更加详细;关键词，用绝对的与内容相关的词语，多个关键词用逗号分开</p>
<br />

<p>(2)外链锚文本的多样化<br>在外链建设上，切忌内容单一，这样很容易造成网站的过度优化，而我们都知道，网站的过度优化对SEO而言是不利的</p>
<br />

<p>(3)网站标签的运用<br>合理的运用网站标签可以让搜索引擎更好的理解网站的层次内容，比如h标签，strong标签等等</p>
<br />

<p>(4)符合国际标准<br>这里所说的符合国际标准指的是告诉搜索引擎我的网站符合W3C标准，对任何浏览器都是兼容的</p>
<br />

<p>(5)代码优化<br>CSS和JS的优化，尽可能的使用外部导入，从而让网页代码更加简洁，能用CSS就尽量不用JS，毕竟JS对于搜索引擎而言并不友好</p>
<br />

<p>(6)图片的优化</p>
<br />

<p>(7)合理设置锚点<br>有一些单页面为了展示很多产品特点，页面会拉的很长，不利于用户查看，用户体验并不好，如果在单页面网站上设置合理的锚点，用户只需要点击一下快速达到想要看到的内容区域</p>
<br />

<p>(8)避免全是图片展示<br>如果单页面网站为了提升视觉效果从而更多的使用图片，那么就会造成网站文字内容过少，不利于搜索引擎对网站的抓取和索引</p>
<br />

<p>(9)内容为王<br>之前我们就举过百度百科的例子，而作为单页面网站来讲，将用户所有的需求点尽可能完整的展现出来，从而解决用户的烦恼才是单页面网站立足的关键</p>
</li>
</ul>
<h1 id="30-你使用过-Promises-及其-polyfills-吗-请写出-Promise-的基本用法（ES6）"><a href="#30-你使用过-Promises-及其-polyfills-吗-请写出-Promise-的基本用法（ES6）" class="headerlink" title="30-你使用过 Promises 及其 polyfills 吗? 请写出 Promise 的基本用法（ES6）"></a>30-你使用过 Promises 及其 polyfills 吗? 请写出 Promise 的基本用法（ES6）</h1><p>Polyfills的意思为：<strong>用于实现浏览器并不支持的原生API的代码</strong></p>
<p>Promise的核心思想是<strong>如果数据就绪(promised)，那么(then)做点什么</strong>.</p>
<p>下文是一个promise实例:</p>
<pre><code>const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});</code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</p>
<p><strong>resolve函数的作用是</strong>：将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p>
<p><strong>reject函数的作用是</strong>：将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为rejected）， 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数</p>
<pre><code>promise.then(function(value) {
  // success
}, function(error) {
  // failure
});</code></pre><p>下面是一个<code>Promise</code>对象的简单例子:</p>
<pre><code class="javascript">function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(resolve, ms, &#39;done&#39;);
  });
}

timeout(100).then((value) =&gt; {
  console.log(value);
});</code></pre>
<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数</p>
<h1 id="31-使用-Promises-而非回调-callbacks-优缺点是什么？"><a href="#31-使用-Promises-而非回调-callbacks-优缺点是什么？" class="headerlink" title="31-使用 Promises 而非回调 (callbacks) 优缺点是什么？"></a>31-使用 Promises 而非回调 (callbacks) 优缺点是什么？</h1><p>相比于 callback<br>Promise 具有更易读的代码组织形式（将有依赖的异步操作使用链式结构组织起来）；更好的异常处理方式（无需为每个异步操作添加异常处理，只需在调用 Promise 的末尾添加上一个<code>catch</code>方法捕获异常即可）；以及异步操作并行处理的能力（<code>Promise.all()</code>）等优点。</p>
<h1 id="32-使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？"><a href="#32-使用一种可以编译成-JavaScript-的语言来写-JavaScript-代码有哪些优缺点？" class="headerlink" title="32-使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？"></a>32-使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？</h1><p>优点：<br>（1）编写的过程中的代码应该是写法简洁，清晰<br>（2）可读性好</p>
<p>缺点：在运行之前需要一定时间进行代码转换</p>
<h1 id="33-你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？"><a href="#33-你会使用怎样的语言结构来遍历对象属性-object-properties-和数组内容？" class="headerlink" title="33-你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？"></a>33-你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？</h1><p>（1）for in 语句<br>（2）一般for循环<br>（3）数组forEach方法</p>
<h1 id="34-可变-mutable-和不变-immutable-对象的区别"><a href="#34-可变-mutable-和不变-immutable-对象的区别" class="headerlink" title="34-可变 (mutable) 和不变 (immutable) 对象的区别"></a>34-可变 (mutable) 和不变 (immutable) 对象的区别</h1><p><strong>可变（Mutable）对象：</strong><br>  在JavaScript中，对象是引用类型的数据，其优点在于频繁地修改对象时都是在原对象的基础上修改，并不需要重新创建，这样就可以有效地利用内存，不会造成内存空间的浪费</p>
<p><strong>不变（Immutable）对象：</strong><br>  每次修改一个immutable对象时都会创建一个新的不可变对象，在新对象上的操作不会影响到原对象的数据</p>
<p><strong>区别：</strong><br>Immutable对象在修改数据时并不会复制一整份数据，而是将变化的节点与未变化的节点的父子关系转移到一个新节点上<br>而Mutable在复制时是“全量”，Immutable对象需要通过set和get来对数据进行读和写</p>
<p><strong>举出 JavaScript 中一个不变性对象 (immutable object) 的例子</strong><br>例如：String， number就是不可变对象</p>
<p><strong>不变性 (immutability) 优缺点</strong><br><strong>优点:</strong><br> (1)降低 Mutable 带来的复杂度<br>  引用赋值虽然可以节省内存，但当应用复杂之后，可变状态往往会变成噩梦，通常一般的做法是使用shallowCopy或者deepCopy来避免被修改，但这样造成了CPU和内存的消耗，不过Immulate可以很好地解决这些问题</p>
<p> (2)节省内存空间<br>  上面提到了结构共享，Immutable.js 使用这种方式会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收</p>
<p> (3)Undo/Redo，Copy/Paste，随意穿越！<br>  因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能</p>
<p> (4)拥抱函数式编程<br>  Immutable（持久化数据结构）本身就是函数式编程中的概念。函数式编程关心数据的映射，命令式编程关心解决问题的步骤，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装</p>
<p><strong>缺点:</strong>容易与原生对象混</p>
<p><strong>如何用你自己的代码来实现不变性 (immutability)</strong><br>例如定义一个不可变更，不可枚举的变量</p>
<h1 id="35-请解释同步-synchronous-和异步-asynchronous-函数的区别"><a href="#35-请解释同步-synchronous-和异步-asynchronous-函数的区别" class="headerlink" title="35-请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别"></a>35-请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别</h1><ul>
<li><p>同步调用，在发起一个函数或方法调用时，没有得到结果之前，该调用就不返回，直到返回结果</p>
<br />
</li>
<li><p>异步调用的概念和同步相对，在一个异步调用发起后，被调用者立即返回给调用者，但调用者不能立刻得到结果，被调用者在实际处理这个调用的请求完成后，通过状态、通知或回调等方式来通知调用者请求处理的结果</p>
<br />

</li>
</ul>
<p>简单地说，同步就是发出一个请求后什么事都不做，一直等待请求返回后才会继续做事；异步就是发出请求后继续去做其他事，这个请求处理完成后会通知你，这时候就可以处理这个回应了</p>
<h1 id="36-什么是事件循环-event-loop-？"><a href="#36-什么是事件循环-event-loop-？" class="headerlink" title="36-什么是事件循环 (event loop)？"></a>36-什么是事件循环 (event loop)？</h1><p>Event Loop是浏览器和NodeJS用来解决Javascript单线程运行带来的问题的一种运行机制；在不同的地方有不同的实现；浏览器和NodeJS基于不同的技术实现了各自的Event Loop</p>
<ul>
<li><p>浏览器的Event Loop是在<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener">html5的规范</a>中明确定义。</p>
</li>
<li><p>NodeJS的Event Loop是基于libuv实现的。可以参考Node的<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">官方文档</a>以及libuv的<a href="http://docs.libuv.org/en/v1.x/design.html" target="_blank" rel="noopener">官方文档</a>。</p>
</li>
<li><p>libuv已经对Event Loop做出了实现，而HTML5规范中只是定义了浏览器中Event Loop的模型，具体的实现留给了浏览器厂商。</p>
</li>
</ul>
<p>运行以后的程序叫做<a href="http://zh.wikipedia.org/wiki/进程" target="_blank" rel="noopener">“进程”</a>（process），一般情况下，一个进程一次只能执行一个任务</p>
<p>如果有很多任务需要执行，不外乎三种解决方法：</p>
<p> <strong>（1）排队</strong>因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务</p>
<p> <strong>（2）新建进程</strong>使用fork命令，为每个任务新建一个进程</p>
<p> <strong>（3）新建线程</strong>因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务（进程和线程的详细解释，请看<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">这里</a>)</p>
<h2 id="堆、栈、队列"><a href="#堆、栈、队列" class="headerlink" title="堆、栈、队列"></a>堆、栈、队列</h2><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><ol>
<li><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树</p>
<br />
</li>
<li><p>堆分为两种情况，有最大堆和最小堆；将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆</p>
<br />
</li>
<li><p>堆在程序运行时而不是在程序编译时申请的动态内存，一般是申请/给予的过程，堆用来存储对象的值，并会用一个地址来记录存储值的位置，该地址存储在命名对象的变量中（即存储在栈内存中），因此复制这个变量只是复制了地址，而不是复制了对象</p>
</li>
</ol>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><ol>
<li><p>栈是一种运算受限的线性表，只被运行在表尾进行插入和删除操作。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈</p>
<br />
</li>
<li><p>栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。可以想象为一个桶，后放进去的东西会先拿出来，而且只能在桶口操作。栈定义了两个方法：</p>
<ul>
<li>PUSH操作在堆栈的顶部加入一个元素。</li>
<li>POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一</li>
</ul>
</li>
</ol>
<blockquote>
<p>其实堆栈本身就是栈，只是换了个抽象的名字；栈的空间一般由程序员释放，会用来存储javascript基本类型的值以及引用对象的引用地址</p>
</blockquote>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ol>
<li><p>队列是一种特殊的线性表，只运行在表的前端进行删除操作，表的后端进行插入操作，进行插入操作的端称为队尾，进行删除操作的端称为队头</p>
<br />
</li>
<li><p>队列中没有元素时，称为空队列</p>
<br />
</li>
<li><p>队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构；也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来</p>
</li>
</ol>
<h3 id="宏队列和微队列"><a href="#宏队列和微队列" class="headerlink" title="宏队列和微队列"></a>宏队列和微队列</h3><p><strong>宏队列，macrotask，也叫tasks</strong> </p>
<p>一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：</p>
<pre><code>setTimeout
setInterval
setImmediate (Node独有)
requestAnimationFrame (浏览器独有)
I/O
UI rendering (浏览器独有)</code></pre><p><strong>微队列，microtask，也叫jobs</strong><br>另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：</p>
<pre><code>process.nextTick (Node独有)
Promise
Object.observe
MutationObserver</code></pre><p>（注：这里只针对浏览器和NodeJS）</p>
<h3 id="浏览器的Event-Loop"><a href="#浏览器的Event-Loop" class="headerlink" title="浏览器的Event Loop"></a>浏览器的Event Loop</h3><p><img src="https://segmentfault.com/img/remote/1460000016278118?w=710&h=749" alt="browser-eventloop"></p>
<p>这张图将浏览器的Event Loop完整的描述了出来，我来讲执行一个JavaScript代码的具体流程：</p>
<ol>
<li><p>执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）</p>
</li>
<li><p>全局Script代码执行完毕后，调用栈Stack会清空</p>
</li>
<li><p>从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1</p>
</li>
<li><p>继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕</p>
</li>
</ol>
<blockquote>
<p><strong>注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行</strong></p>
</blockquote>
<ol start="5">
<li><p>microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空</p>
</li>
<li><p>取出宏队列macrotask queue中位于队首的任务，放入Stack中执行</p>
</li>
<li><p>执行完毕后，调用栈Stack为空</p>
</li>
<li><p>重复第3-7个步骤；</p>
</li>
<li><p>重复第3-7个步骤；</p>
</li>
<li><p>……</p>
<br />


</li>
</ol>
<p><strong>可以看到，这就是浏览器的事件循环Event Loop</strong><br>这里归纳3个重点：</p>
<ol>
<li><p>宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务</p>
</li>
<li><p>微任务队列中所有的任务都会被依次取出来执行，知道microtask queue为空</p>
</li>
<li><p>图中没有画UI rendering的节点，因为这个是由浏览器自行判断决定的，但是只要执行UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render</p>
</li>
</ol>
<p>实例:</p>
<pre><code>console.log(1);

setTimeout(() =&gt; {
  console.log(2);
  Promise.resolve().then(() =&gt; {
    console.log(3)
  });
});

new Promise((resolve, reject) =&gt; {
  console.log(4)
  resolve(5)
}).then((data) =&gt; {
  console.log(data);
})

setTimeout(() =&gt; {
  console.log(6);
})

console.log(7);

//答案：1 4 7 5 2 3 6</code></pre><p>我们来分析一下整个流程：</p>
<ul>
<li>执行全局Script代码</li>
</ul>
<p><strong>Step 1：</strong></p>
<pre><code>console.log(1)</code></pre><p>Stack Queue: [console]<br>Macrotask Queue: []<br>Microtask Queue: []<br>打印结果：1</p>
<p><strong>Step 2：</strong></p>
<pre><code>setTimeout(() =&gt; {
  // 这个回调函数叫做callback1，setTimeout属于macrotask，所以放到macrotask queue中
  console.log(2);
  Promise.resolve().then(() =&gt; {
    console.log(3)
  });
});</code></pre><p>Stack Queue: [setTimeout]<br>Macrotask Queue: [callback1]<br>Microtask Queue: []<br>打印结果：1</p>
<p><strong>Step 3：</strong></p>
<pre><code>new Promise((resolve, reject) =&gt; {
  // 注意，这里是同步执行的，如果不太清楚，可以去看一下我开头自己实现的promise啦~~
  console.log(4)
  resolve(5)
}).then((data) =&gt; {
  // 这个回调函数叫做callback2，promise属于microtask，所以放到microtask queue中
  console.log(data);
})</code></pre><p>Stack Queue: [promise]<br>Macrotask Queue: [callback1]<br>Microtask Queue: [callback2]<br>打印结果：1、4</p>
<p><strong>Step 4：</strong></p>
<pre><code>setTimeout(() =&gt; {
  // 这个回调函数叫做callback3，setTimeout属于macrotask，所以放到macrotask queue中
  console.log(6);
})</code></pre><p>Stack Queue: [setTimeout]<br>Macrotask Queue: [callback1, callback3]<br>Microtask Queue: [callback2]<br>打印结果：1、4</p>
<p><strong>Step 5：</strong></p>
<pre><code>console.log(7)</code></pre><p>Stack Queue: [console]<br>Macrotask Queue: [callback1, callback3]<br>Microtask Queue: [callback2]<br>打印结果：1、4、7</p>
<p><strong>全局Script代码执行完了，进入下一个步骤，从microtask queue中依次取出任务执行，直到microtask queue队列为空</strong></p>
<p><strong>Step 6：</strong></p>
<pre><code>console.log(data) // 这里data是Promise的决议值5</code></pre><p>Stack Queue: [callback2]<br>Macrotask Queue: [callback1, callback3]<br>Microtask Queue: []<br>打印结果：1、4、7、5</p>
<p><strong>注：</strong>这里microtask queue中只有一个任务，执行完后开始从宏任务队列macrotask queue中取位于队首的任务执行</p>
<p><strong>Step 7：</strong></p>
<pre><code>console.log(2)</code></pre><p>Stack Queue: [callback1]<br>Macrotask Queue: [callback3]<br>Microtask Queue: []<br>打印结果：1、4、7、5、2</p>
<p>但是，执行callback1的时候又遇到了另一个Promise，Promise异步执行完后在microtask queue中又注册了一个callback4回调函数</p>
<p><strong>Step 8：</strong></p>
<pre><code>Promise.resolve().then(() =&gt; {
  // 这个回调函数叫做callback4，promise属于microtask，所以放到microtask queue中
  console.log(3)
});</code></pre><p>Stack Queue: [promise]<br>Macrotask v: [callback3]<br>Microtask Queue: [callback4]<br>打印结果：1、4、7、5、2</p>
<p>这里，取出一个宏任务macrotask执行完毕，然后再去微任务队列microtask queue中依次取出执行</p>
<p><strong>Step 9：</strong></p>
<pre><code>console.log(3)</code></pre><p>Stack Queue: [callback4]<br>Macrotask Queue: [callback3]<br>Microtask Queue: []<br>打印结果：1、4、7、5、2、3</p>
<p>这里，微任务队列全部执行完，再去宏任务队列中取第一个任务执行</p>
<p><strong>Step 10：</strong></p>
<pre><code>console.log(6)</code></pre><p>Stack Queue: [callback3]<br>Macrotask Queue: []<br>Microtask Queue: []<br>打印结果：1、4、7、5、2、3、6</p>
<p>以上，全部执行完后，Stack Queue为空，Macrotask Queue为空，Micro Queue为空</p>
<p>Stack Queue: []<br>Macrotask Queue: []<br>Microtask Queue: []<br>最终打印结果：1、4、7、5、2、3、6</p>
<h3 id="再来一个例子"><a href="#再来一个例子" class="headerlink" title="再来一个例子"></a><strong>再来一个例子</strong></h3><pre><code>console.log(1);

setTimeout(() =&gt; {
  console.log(2);
  Promise.resolve().then(() =&gt; {
    console.log(3)
  });
});

new Promise((resolve, reject) =&gt; {
  console.log(4)
  resolve(5)
}).then((data) =&gt; {
  console.log(data);

  Promise.resolve().then(() =&gt; {
    console.log(6)
  }).then(() =&gt; {
    console.log(7)

    setTimeout(() =&gt; {
      console.log(8)
    }, 0);
  });
})

setTimeout(() =&gt; {
  console.log(9);
})

console.log(10);</code></pre><p>最终输出结果是什么呢？参考前面的例子，好好想一想……</p>
<pre><code>// 正确答案：1、4、10、5、6、7、2、3、9、8</code></pre><p>相信大家都答对了，这里的关键在前面已经提过：<br><strong>在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止</strong></p>
<p>注：当然如果你在microtask中不断的产生microtask，那么其他宏任务macrotask就无法执行了，但是这个操作也不是无限的，拿NodeJS中的微任务process.nextTick()来说，它的上限是1000个，后面我们会讲到</p>
<p>浏览器的Event Loop就说到这里，下面我们看一下NodeJS中的Event Loop，它更复杂一些，机制也不太一样.</p>
<h3 id="NodeJS中的Event-Loop"><a href="#NodeJS中的Event-Loop" class="headerlink" title="NodeJS中的Event Loop"></a>NodeJS中的Event Loop</h3><h3 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h3><p>先来看一张libuv的结构图：<br><img src="https://segmentfault.com/img/remote/1460000016278119?w=800&h=316" alt="node-libuv"></p>
<h3 id="NodeJS中的宏队列和微队列"><a href="#NodeJS中的宏队列和微队列" class="headerlink" title="NodeJS中的宏队列和微队列"></a>NodeJS中的宏队列和微队列</h3><p>NodeJS的Event Loop中，执行宏队列的回调任务有<strong>6个阶段</strong>，如下图：<br><img src="https://segmentfault.com/img/remote/1460000016278120?w=670&h=339" alt="node-eventloop-6phase"></p>
<p>各个阶段执行的任务如下：</p>
<ul>
<li><p><strong>timers阶段</strong>：这个阶段执行setTimeout和setInterval预定的callback</p>
<br />
</li>
<li><p><strong>I/O callback阶段</strong>：执行除了close事件的callbacks、被timers设定的<br>callbacks、setImmediate()设定的callbacks这些之外的callbacks</p>
<br />
</li>
<li><p><strong>idle, prepare阶段</strong>：仅node内部使用</p>
<br />
</li>
<li><p><strong>poll阶段：获取新的I/O事件</strong>，适当的条件下node将阻塞在这里</p>
<br />
</li>
<li><p><strong>check阶段</strong>：执行setImmediate()设定的callbacks</p>
<br />
</li>
<li><p><strong>close callbacks阶段</strong>：执行socket.on(‘close’, ….)这些callbacks</p>
</li>
</ul>
<p><strong>NodeJS中宏队列主要有4个</strong></p>
<p>由上面的介绍可以看到，回调事件主要位于4个macrotask queue中：</p>
<ol>
<li>Timers Queue</li>
<li>IO Callbacks Queue</li>
<li>Check Queue</li>
<li>Close Callbacks Queue</li>
</ol>
<p>这4个都属于宏队列，但是在浏览器中，可以认为只有一个宏队列，所有的macrotask都会被加到这一个宏队列中，但是在NodeJS中，不同的macrotask会被放置在不同的宏队列中</p>
<p><strong>NodeJS中微队列主要有2个</strong>：</p>
<ol>
<li>Next Tick Queue：是放置process.nextTick(callback)的回调任务的</li>
<li>Other Micro Queue：放置其他microtask，比如Promise等</li>
</ol>
<p>在浏览器中，也可以认为只有一个微队列，所有的microtask都会被加到这一个微队列中，但是在NodeJS中，不同的microtask会被放置在不同的微队列中</p>
<p>具体可以通过下图加深一下理解：</p>
<p><img src="https://segmentfault.com/img/remote/1460000016278121?w=951&h=526" alt="node-eventloop"></p>
<p>大体解释一下NodeJS的Event Loop过程：</p>
<ol>
<li><p>执行全局Script的同步代码</p>
<br />
</li>
<li><p>执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务</p>
<br />
</li>
<li><p>开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就是步骤2</p>
<br />
</li>
<li><p>Timers Queue -&gt; 步骤2 -&gt; I/O Queue -&gt; 步骤2 -&gt; Check Queue -&gt; 步骤2 -&gt; Close Callback Queue -&gt; 步骤2 -&gt; Timers Queue ……</p>
<br />
</li>
<li><p>这就是Node的Event Loop</p>
</li>
</ol>
<p><strong>关于NodeJS的macrotask queue和microtask queue，我画了两张图，大家作为参考：</strong></p>
<p><img src="https://segmentfault.com/img/remote/1460000016278122?w=420&h=433" alt="node-microtaskqueue"></p>
<p><img src="https://segmentfault.com/img/remote/1460000016278123?w=676&h=449" alt="node-macrotaskqueue"></p>
<p>好啦，概念理解了我们通过几个例子来实战一下：</p>
<p>第一个例子</p>
<pre><code>console.log(&#39;start&#39;);

setTimeout(() =&gt; {          // callback1
  console.log(111);
  setTimeout(() =&gt; {        // callback2
    console.log(222);
  }, 0);
  setImmediate(() =&gt; {      // callback3
    console.log(333);
  })
  process.nextTick(() =&gt; {  // callback4
    console.log(444);  
  })
}, 0);

setImmediate(() =&gt; {        // callback5
  console.log(555);
  process.nextTick(() =&gt; {  // callback6
    console.log(666);  
  })
})

setTimeout(() =&gt; {          // callback7              
  console.log(777);
  process.nextTick(() =&gt; {  // callback8
    console.log(888);   
  })
}, 0);

process.nextTick(() =&gt; {    // callback9
  console.log(999);  
})

console.log(&#39;end&#39;);</code></pre><p>请运用前面学到的知识，仔细分析一下……</p>
<pre><code>// 正确答案
start
end
999
111
777
444
888
555
333
666
222</code></pre><p>上面这段代码你执行的结果可能会有多种情况，原因解释如下。<br>  setTimeout(fn, 0)不是严格的0，一般是setTimeout(fn, 3)或什么，会有一定的延迟时间，当setTimeout(fn, 0)和setImmediate(fn)出现在同一段同步代码中时，就会存在两种情况</p>
<ul>
<li><p><strong>第1种情况</strong>：同步代码执行完了，Timer还没到期，setImmediate回调先注册到Check Queue中，开始执行微队列，然后是宏队列，先从Timers Queue中开始，发现没回调，往下走直到Check Queue中有回调，执行，然后timer到期（只要在执行完Timer Queue后到期效果就都一样），timer回调注册到Timers Queue中，下一轮循环执行到Timers Queue中才能执行那个timer 回调；<strong>所以，这种情况下，setImmediate(fn)回调先于setTimeout(fn, 0)回调执行</strong></p>
<br />
</li>
<li><p><strong>第2种情况</strong>：同步代码还没执行完，timer先到期，timer回调先注册到Timers Queue中，执行到setImmediate了，它的回调再注册到Check Queue中。 然后，同步代码执行完了，执行微队列，然后开始先执行Timers Queue，先执行Timer 回调，再到Check Queue，执行setImmediate回调；<strong>所以，这种情况下，setTimeout(fn, 0)回调先于setImmediate(fn)回调执行</strong></p>
<br />
</li>
<li><p>所以，在同步代码中同时调setTimeout(fn, 0)和setImmediate情况是不确定的，但是如果把他们放在一个IO的回调，比如readFile(‘xx’, function () {// ….})回调中，那么IO回调是在IO Queue中，setTimeout到期回调注册到Timers Queue，setImmediate回调注册到Check Queue，IO Queue执行完到Check Queue，timer Queue得到下个周期，所以setImmediate回调这种情况下肯定比setTimeout(fn, 0)回调先执行</p>
<br />

</li>
</ul>
<p>综上，这个例子是不太好的，setTimeout(fn, 0)和setImmediate(fn)如果想要保证结果唯一，就放在一个IO Callback中吧，上面那段代码可以把所有它俩同步执行的代码都放在一个IO Callback中，结果就唯一了</p>
<p>你答对了吗？我们来一起分析一下：</p>
<ol>
<li><p>执行全局Script代码，先打印<strong>start</strong>，向下执行，将setTimeout的回调callback1注册到Timers Queue中</p>
</li>
<li><p>再向下执行，将setImmediate的回调callback5注册到Check Queue中</p>
</li>
<li><p>接着向下执行，将setTimeout的回调callback7注册到Timers Queue中</p>
</li>
<li><p>继续向下，将process.nextTick的回调callback9注册到微队列Next Tick Queue中</p>
</li>
<li><p>最后一步打印end，此时，各个队列的回调情况如下：</p>
</li>
</ol>
<p><strong>宏队列:</strong><br>Timers Queue: [callback1, callback7]<br>Check Queue: [callback5]<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列:</strong><br>Next Tick Queue: [callback9]<br>Other Microtask Queue: []<br>打印结果：start、end</p>
<p>全局Script执行完了，开始依次执行微任务Next Tick Queue中的全部回调任务。此时Next Tick Queue中只有一个callback9，将其取出放入调用栈中执行，打印<strong>999</strong></p>
<p><strong>宏队列:</strong><br>Timers Queue: [callback1, callback7]<br>Check Queue: [callback5]<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列:</strong><br>Next Tick Queue: []<br>Other Microtask Queue: []</p>
<pre><code>打印结果:
start
end
999</code></pre><p>开始依次执行6个阶段各自宏队列中的所有任务</p>
<ol>
<li><p>先执行第1个阶段Timers Queue中的所有任务，先取出callback1执行，打印<strong>111</strong></p>
</li>
<li><p>callback1函数继续向下，依次把callback2放入Timers Queue中，把callback3放入Check Queue中，把callback4放入Next Tick Queue中，然后callback1执行完毕</p>
</li>
<li><p>再取出Timers Queue中此时排在首位的callback7执行，打印<strong>777</strong>，把callback8放入Next Tick Queue中，执行完毕</p>
</li>
</ol>
<p>此时，各队列情况如下：<br><strong>宏队列:</strong><br>Timers Queue: [callback2]<br>Check Queue: [callback5, callback3]<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列:</strong><br>Next Tick Queue: [callback4, callback8]<br>Other Microtask Queue: []</p>
<pre><code>打印结果
start
end
999
111
777</code></pre><p>6个阶段每阶段的宏任务队列执行完毕后，都会开始执行微任务</p>
<ol>
<li><p>此时，先取出Next Tick Queue中的所有任务执行，callback4开始执行，打印<strong>444</strong></p>
</li>
<li><p>然后callback8开始执行，打印<strong>888</strong>，Next Tick Queue执行完毕，开始执行Other Microtask Queue中的任务，因为里面为空，所以继续向下:</p>
</li>
</ol>
<p><strong>宏队列:</strong><br>Timers Queue: [callback2]<br>Check Queue: [callback5, callback3]<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列:</strong><br>Next Tick Queue: []<br>Other Microtask Queue: []</p>
<pre><code> 打印结果
 start
 end
 999
 111
 777
 444
 888</code></pre><ol>
<li>第2个阶段IO Callback Queue队列为空，跳过</li>
<li>第3和第4个阶段一般是Node内部使用，跳过</li>
<li>进入第5个阶段Check Queue，取出callback5执行，打印<strong>555</strong>，把callback6放入Next Tick Queue中，执行callback3，打印<strong>333</strong>：</li>
</ol>
<p><strong>宏队列：</strong><br>Timers Queue: [callback2]<br>Check Queue: []<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列：</strong><br>Next Tick Queue: [callback6]<br>Other Microtask Queue: []</p>
<pre><code> 打印结果
 start
 end
 999
 111
 777
 444
 888
 555
 333</code></pre><ol>
<li>执行微任务队列，先执行Next Tick Queue，取出callback6执行，打印<strong>666</strong>，执行完毕，因为Other Microtask Queue为空，跳过：</li>
</ol>
<p><strong>宏队列:</strong><br>Timers Queue: [callback2]<br>Check Queue: []<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列:</strong><br>Next Tick Queue: [callback6]<br>Other Microtask Queue: []</p>
<pre><code> 打印结果
 start
 end
 999
 111
 777
 444
 888
 555
 333</code></pre><ol>
<li><p>执行第6个阶段Close Callback Queue中的任务，为空，跳过，好了，此时一个循环已经结束</p>
</li>
<li><p>进入下一个循环，执行第1个阶段Timers Queue中的所有任务，取出callback2执行，打印<strong>222</strong>，完毕</p>
</li>
<li><p>此时，所有队列包括宏任务队列和微任务队列都为空，不再打印任何东西</p>
</li>
</ol>
<p><strong>宏队列:</strong><br>Timers Queue: []<br>Check Queue: []<br>IO Callback Queue： []<br>Close Callback Queue: []</p>
<p><strong>微队列:</strong><br>Next Tick Queue: [callback6]<br>Other Microtask Queue: []</p>
<pre><code> 打印结果
 start
 end
 999
 111
 777
 444
 888
 555
 333
 666
 222</code></pre><p>以上就是这道题目的详细分析，如果没有明白，一定要多看几次</p>
<h3 id="下面引入Promise再来看一个例子："><a href="#下面引入Promise再来看一个例子：" class="headerlink" title="下面引入Promise再来看一个例子："></a>下面引入Promise再来看一个例子：</h3><pre><code>console.log(&#39;1&#39;);

setTimeout(function() {
    console.log(&#39;2&#39;);
    process.nextTick(function() {
        console.log(&#39;3&#39;);
    })
    new Promise(function(resolve) {
        console.log(&#39;4&#39;);
        resolve();
    }).then(function() {
        console.log(&#39;5&#39;)
    })
})

new Promise(function(resolve) {
    console.log(&#39;7&#39;);
    resolve();
}).then(function() {
    console.log(&#39;8&#39;)
})
process.nextTick(function() {
  console.log(&#39;6&#39;);
})

setTimeout(function() {
    console.log(&#39;9&#39;);
    process.nextTick(function() {
        console.log(&#39;10&#39;);
    })
    new Promise(function(resolve) {
        console.log(&#39;11&#39;);
        resolve();
    }).then(function() {
        console.log(&#39;12&#39;)
    })
})</code></pre><ol>
<li><p>大家仔细分析，相比于上一个例子，这里由于存在Promise，所以Other Microtask Queue中也会有回调任务的存在</p>
</li>
<li><p>执行到微任务阶段时，先执行Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务，然后才会进入下一个阶段的宏任务</p>
</li>
<li><p>明白了这一点，相信大家都可以分析出来，下面直接给出正确答案</p>
</li>
</ol>
<p>// 正确答案<br>1<br>7<br>6<br>8<br>2<br>4<br>9<br>11<br>3<br>10<br>5<br>12</p>
<h3 id="setTimeout-对比-setImmediate"><a href="#setTimeout-对比-setImmediate" class="headerlink" title="setTimeout 对比 setImmediate"></a>setTimeout 对比 setImmediate</h3><ol>
<li>setTimeout(fn, 0)在Timers阶段执行，并且是在poll阶段进行判断是否达到指定的timer时间才会执行</li>
<li>setImmediate(fn)在Check阶段执行<br>两者的执行顺序要根据当前的执行环境才能确定：</li>
</ol>
<ul>
<li>如果两者都在主模块(main module)调用，那么执行先后取决于进程性能，顺序随机</li>
<li>如果两者都不在主模块调用，即在一个I/O Circle中调用，那么setImmediate的回调永远先执行，因为会先到Check阶段</li>
</ul>
<h3 id="setImmediate-对比-process-nextTick"><a href="#setImmediate-对比-process-nextTick" class="headerlink" title="setImmediate 对比 process.nextTick"></a>setImmediate 对比 process.nextTick</h3><ul>
<li>setImmediate(fn)的回调任务会插入到宏队列Check Queue中</li>
<li>process.nextTick(fn)的回调任务会插入到微队列Next Tick Queue中</li>
<li>process.nextTick(fn)调用深度有限制，上限是1000，而setImmedaite则没有</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>浏览器的Event Loop和NodeJS的Event Loop是不同的，实现机制也不一样，不要混为一谈</p>
<br />
</li>
<li><p>浏览器可以理解成只有1个宏任务队列和1个微任务队列，先执行全局Script代码，执行完同步代码调用栈清空后，从微任务队列中依次取出所有的任务放入调用栈执行，微任务队列清空后，从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里和Node的区别，只取一个，然后继续执行微队列中的所有任务，再去宏队列取一个，以此构成事件循环</p>
<br />
</li>
<li><p>NodeJS可以理解成有4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段。先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务队列Next Tick Queue中依次取出所有的任务放入调用栈中执行，再从微任务队列Other Microtask Queue中依次取出所有的任务放入调用栈中执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行（注意，这里和浏览器不一样，浏览器只取一个），每个宏任务阶段执行完毕后，开始执行微任务，再开始执行下一阶段宏任务，以此构成事件循环</p>
<br />
</li>
<li><p>MacroTask包括： setTimeout、setInterval、 setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering</p>
<br />
</li>
<li><p>Microtask包括： process.nextTick(Node)、Promise、Object.observe、MutationObserver</p>
</li>
</ol>
<h1 id="37-调用栈-call-stack-和任务队列-task-queue-的区别是什么？"><a href="#37-调用栈-call-stack-和任务队列-task-queue-的区别是什么？" class="headerlink" title="37-调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？"></a>37-调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？</h1><ol>
<li><p>栈是一种运算受限的线性表，只被运行在表尾进行插入和删除操作。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈</p>
</li>
<li><p>栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。可以想象为一个桶，后放进去的东西会先拿出来，而且只能在桶口操作</p>
</li>
</ol>
<p>栈定义了两个方法：push、pop</p>
<ol>
<li><p>队列是一种特殊的线性表，只运行在表的前端进行删除操作，表的后端进行插入操作，进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列</p>
</li>
<li><p>队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来</p>
</li>
</ol>
<p>队列定义了两个方法：shift、unshift</p>
<h1 id="38-function-foo-与-var-foo-function-用法的区别"><a href="#38-function-foo-与-var-foo-function-用法的区别" class="headerlink" title="38-function foo() {} 与 var foo = function() {}用法的区别"></a>38-function foo() {} 与 var foo = function() {}用法的区别</h1><p><code>function foo(){}</code>为函数声明，进行了变量提升( 编译后函数声明和他的赋值都会被提前),函数声明过程在整个程序执行之前的预处理就完成了，所以只要处于同一个作用域，就可以访问到，即使在定义之前调用它也可以</p>
<p>但是<code>var foo = function(){}</code>只是声明了一个变量，然后进行赋值操作，变量会提升但是赋值不会提升；因为匿名函数只有在被调用时才被初始化</p>
<p><strong>简单的说，如果我们使用匿名函数：</strong></p>
<pre><code>var FUNCTION_NAME = function() { 
  /* FUNCTION_BODY */
}; </code></pre><p>这种方式，编译后变量声明FUNCTION_NAME 会“被提前”了，但是他的赋值（也就是FUNCTION_BODY）并不会被提前；也就是，匿名函数只有在被调用时才被初始化.</p>
<p><strong>如果我们使用：</strong></p>
<pre><code>function FUNCTION_NAME () 
{ /* FUNCTION_BODY */}; </code></pre><p>这种方式， 编译后函数声明和他的赋值都会被提前；也就是说函数声明过程在整个程序执行之前的预处理就完成了，所以只要处于同一个作用域，就可以访问到，即使在定义之前调用它也可以.</p>
<p><strong>请先看一个例子：</strong></p>
<pre><code>function hereOrThere() { //function statement
  return &#39;here&#39;;
}

alert(hereOrThere()); // alerts &#39;there&#39;

function hereOrThere() {
  return &#39;there&#39;;
}</code></pre><p>我们会发现<code>alert(hereOrThere)</code>语句执行时<code>会alert(&#39;there&#39;)！</code>这里的行为其实非常出乎意料，主要原因是JavaScript 函数声明的“提前”行为，简而言之，就是Javascript允许我们在变量和函数被声明之前使用它们，而第二个定义覆盖了第一种定义.</p>
<p><strong>换句话说，上述代码编译之后相当于：</strong></p>
<pre><code>function hereOrThere() { //function statement
  return &#39;here&#39;;
}

function hereOrThere() {//申明前置了，但因为这里的申明和赋值在一起，所以一起前置
  return &#39;there&#39;;
}

alert(hereOrThere()); // alerts &#39;there&#39;</code></pre><p>强烈推荐阅读下面文章，<a href="https://link.zhihu.com/?target=http%3A//www.bootcss.com/article/variable-and-function-hoisting-in-javascript/">JavaScript 中对变量和函数声明的“提前（hoist）”</a>.</p>
<p><strong>再看下面一个例子：</strong></p>
<pre><code>var hereOrThere = function() { // function expression
  return &#39;here&#39;;
};

alert(hereOrThere()); // alerts &#39;here&#39;

hereOrThere = function() {
  return &#39;there&#39;;
};</code></pre><p>这里就是我们期待的behavior，这段程序编译之后相当于：</p>
<pre><code>var hereOrThere；//申明前置了

hereOrThere = function() { // function expression
  return &#39;here&#39;;
};

alert(hereOrThere()); // alerts &#39;here&#39;

hereOrThere = function() {
  return &#39;there&#39;;
};</code></pre></div></div></article></div><div id="gitalk"></div><script>var gitalk = new Gitalk({
    clientID: '007c2e64322ff31b60e9',
    clientSecret: '889ab344b75944a36ccb79dff864e51063bfa5bd',
    id: '2019-12-20 10:10:10',
    repo: 'comments',
    owner: 'kikyoluka',
    admin: 'kikyoluka'
})
gitalk.render('gitalk')</script></div><div class="pjax-main-loading loading"><img class="loading-image" src="/images/loading.gif"></div></main><footer><div class="footer site-info"><p><i class="icon-copyright"></i><span>2018</span>&minus;<span>2020</span>&nbsp;&nbsp;&nbsp;<i class="icon-heart"></i>&nbsp;&nbsp;<span>琉花</span></p><p><a href="https://github.com/sanshiliuxiao/hexo-theme-aurora.git" target="_blank">hexo-theme-Aurora</a>&nbsp; | &nbsp;行至朝雾里 坠入暮云间</p></div></footer></div><div class="bg"><div class="pc-dynamic-bg"><span class="image" data-image="/images/theme/1.jpg"></span><span class="image" data-image="/images/theme/2.jpg"></span><span class="image" data-image="/images/theme/3.jpg"></span><span class="image" data-image="/images/theme/4.jpg"></span><span class="image" data-image="/images/theme/5.jpg"></span><span class="image" data-image="/images/theme/6.jpg"></span><span class="image" data-image="/images/theme/7.jpg"></span><span class="image" data-image="/images/theme/8.jpg"></span><span class="image" data-image="/images/theme/9.jpg"></span></div></div><span class="back-to-top"></span><div class="leancloud"><script src="/js/third-party/leancloud.min.js?version=2.0.0"></script><div class="leancloud-app-id" leancloud-app-id="LjOwR4ELEqbauKvtQbwq5TUw-MdYXbMMI"></div><div class="leancloud-app-key" leancloud-app-key="BOSFJ49ohbGctgn4zvJE9VN6"></div><div class="leancloud-app-hot"></div><div class="leancloud-app-visitor"></div></div><link rel="stylesheet" href="/lib/APlayer/APlayer.min.css"><script src="/lib/APlayer/APlayer.min.js"></script><div id="aplayer"></div><script>let list = JSON.parse('[{"name":"Julia，Train，Slow Down","artist":"Whale Fall","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/JuliaTrainSlowDown.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/5.jpg"},{"name":"The Wellwisher","artist":"Halves","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/TheWellwisher.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/4.jpg"},{"name":"SadSexy","artist":"Dirty Three","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/SadSexy .mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/1.jpg"},{"name":"Riverrun","artist":"Stubborn","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/Riverrun.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/3.jpg"},{"name":"Hortur","artist":"Picastro","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/Hortur.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/2.jpg"}]')
  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      theme: '#b28fce',
      audio: list,
      fixed: true,
      volume: 1
  });
  ap.list.show()
</script><script src="/js/third-party/jquery.min.js?version=2.0.0"></script><script src="/js/third-party/isMobile.min.js?version=2.0.0"></script><script src="/js/third-party/timeago.min.js?version=2.0.0"></script><script src="/js/third-party/pjax.min.js?version=2.0.0"></script><script src="/js/third-party/zooming.min.js?version=2.0.0"></script><script src="/js/third-party/backstretch.min.js?version=2.0.0"></script><script src="/js/highlight.min.js?version=2.0.0"></script><script src="/js/index.js?version=2.0.0"></script></body></html>
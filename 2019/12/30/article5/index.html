<!DOCTYPE html><html lang="ZH-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="author" content="琉花"><meta name="copyright" content="琉花"><meta name="og:image" content="/images/avatar.png"><meta name="og:type" content="website"><meta name="og:site_name" content="琉花"><meta name="og:url" content="kikyoluka.cn"><meta name="og：title" content="琉花"><meta name="theme-color" content="#b854d4" /><title>琉花</title><link rel="shortcut icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/index.css?version=2.0.0"><link rel="stylesheet" href="/font/fontello.css?version=2.0.0"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Mono|Noto+Serif+SC&amp;amp;display=swap"><link rel="canonical" href="//kikyoluka.cn"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script src="/lib/gitalk/gitalk.min.js"></script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="layout"><header><div class="header"><div class="mobile-bg" style="background-image:url(/images/mobile.png);"></div><h1 class="title">琉花</h1><h2 class="subtitle">行至朝雾里 坠入暮云间</h2><nav class="menu"><a class="menu-item pjax-main-link" href="/"><li><i class="icon-index"></i><span>首页</span></li></a><a class="menu-item pjax-main-link" href="/archives/"><li><i class="icon-archives"></i><span>归档</span></li></a><a class="menu-item pjax-main-link" href="/categories/"><li><i class="icon-categories"></i><span>分类</span></li></a><a class="menu-item pjax-main-link" href="/tags/"><li><i class="icon-tags"></i><span>标签</span></li></a><a class="menu-item pjax-main-link" href="/books/"><li><i class="icon-books"></i><span>书单</span></li></a><a class="menu-item pjax-main-link" href="/inspirations/"><li><i class="icon-inspiration"></i><span>灵感</span></li></a><a class="menu-item pjax-main-link" href="/friends/"><li><i class="icon-friends"></i><span>友链</span></li></a><a class="menu-item pjax-main-link" href="/about/"><li><i class="icon-about"></i><span>关于</span></li></a></nav></div></header><main><div class="main-wrapper"></div><div class="pjax-main-page"><div class="post"><article class="post-article"><div class="post-header"><img class="default-image" src="/images/postDefaultImage%20.png" style="opacity:0;"/><img class="post-image" src="https://cdn.jsdelivr.net/gh/chanshiyucx/yoi@latest/bg/21.jpg"/><div class="post-head"><div class="post-title-wrapper"><h1 class="post-title">前端面试题的整理-JS部分</h1><span class="post-image-source">pixiv</span></div><div class="post-meta"><span class="post-date"><i class="icon-calendar"></i><span class="date timeago" datetime="2019-12-30T02:10:10.000Z"></span></span><span class="post-hot"><i class="icon-fire"></i><span class="leancloud_visitors" id="/2019/12/30/article5/" data-flag-title="前端面试题的整理-JS部分">热度<span class="leancloud-visitors-count">0</span>℃</span></span><span class="post-tags"><i class="icon-tag"></i><span class="tag">面试知识</span></span><span class="post-categories"><i class="icon-bookmark-empty"></i><span class="category">笔记</span></span></div></div></div><div class="post-content"><div class="markdown"><h1 id="事件代理-event-delegation"><a href="#事件代理-event-delegation" class="headerlink" title="事件代理 (event delegation)"></a>事件代理 (event delegation)</h1><p>事件代理，即把一个元素响应事件（click、keydown……）的函数委托到另一个元素</p>
<p>一般来说会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p>
<p><strong>那么事件冒泡机制又是什么？</strong><br><strong>“DOM2级事件”规定事件流包括三个阶段</strong>，事件捕获阶段、处于目标阶段和事件冒泡阶段；<strong>首先发生的事件捕获</strong>，为截获事件提供了机会；然后是<strong>实际的目标接收了事件</strong>；最后一个阶段是<strong>冒泡阶段</strong>，可以在这个阶段对事件做出响应</p>
<ul>
<li><strong>事件捕获阶段</strong>：当鼠标点击或者触发dom事件时，浏览器会<strong>从根节点开始由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</li>
</ul>
<ul>
<li><strong>事件目标阶段</strong>：目标阶段就是指事件响应到触发事件的最底层元素上；</li>
</ul>
<ul>
<li><strong>事件冒泡阶段</strong>：冒泡阶段就是事件的触发响应会<strong>从最底层目标一层层地向外到最外层（根节点）</strong>，事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>
</ul>
<ol>
<li><p>事件捕获：<br><img src="https://segmentfault.com/img/remote/1460000012729086" alt="img"></p>
<br />
</li>
<li><p>事件冒泡:<br><img src="https://segmentfault.com/img/remote/1460000012729085" alt="img"></p>
<br />
</li>
<li><p>一个完整的事件流程：<br>从根节点开始一直到目标点，然后再从目标点到根节点<br><img src="https://pic1.zhimg.com/80/v2-4de189d2a42b1e8c74b379e067b67578_hd.jpg" alt="img"></p>
<br />

</li>
</ol>
<p><strong>说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent（<del>当然还有其它的事件绑定的方式这里不做介绍</del>）</strong></p>
<p><strong>addEventListener(event, listener, useCapture)</strong></p>
<p>参数定义：<br>event—（事件名称，如click，不带on）<br>listener—事件监听函数<br>useCapture—是否采用事件捕获进行事件捕捉（默认为false，即采用事件冒泡方式）<br>addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持</p>
<p>那么我们从代码上来看：</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;style&gt;
      #a{
          width: 300px;
          height: 300px;
          background: pink;
      }
      #b{
          width: 200px;
          height: 200px;
          background: blue;
      }
    #c{
        width: 100px;
        height: 100px;
        background: yellow;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;a&quot;&gt;
        &lt;div id=&quot;b&quot;&gt;
            &lt;div id=&quot;c&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;script&gt;
      var a = document.getElementById(&quot;a&quot;),
          b = document.getElementById(&quot;b&quot;),
          c = document.getElementById(&quot;c&quot;);

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c1&quot;);
          // 注意第三个参数没有传进 false , 因为默认传进来的是 false
          //，代表冒泡阶段调用，个人认为处于目标阶段也会调用的
      });

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c2&quot;);
      }, true);

      b.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;b&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a1&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a2&quot;)
      });

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a3&quot;);
          event.stopImmediatePropagation();
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a4&quot;);
      }, true);
  &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li><p>在这个代码中，如果点击c和b的话，根据DOM事件流，应该先从事件捕获开始，那么自然就是从a开始往目标事件进行事件捕获；而代码中只有a1、a3、a4为捕获阶段（因为其addEventListener的第三个参数为true，默认为false–即采用事件冒泡方式），但是a3的event.stopImmediatePropagation();阻止事件的传播（捕获或冒泡），同时也阻止该元素上后来绑定的事件处理程序被调用，所以整个代码就直接被结束了，故只输出a1、a3</p>
<br />
</li>
<li><p>如果点击a的话，目标事件就在a，事件流既不属于捕获也不属于冒泡，事件流处于目标阶段，所以直接按顺序输出a1、a2、a3</p>
<br />
</li>
<li><p>如果注释掉event.stopImmediatePropagation();再点击c的话，从捕获开始a1、a3、a4、b然后到目标阶段c1、c2然后到冒泡阶段a2</p>
<br />

</li>
</ul>
<blockquote>
<p>为什么冒泡阶段不全部再触发一次呢？因为如果同一个事件处理程序（指针相同，比如用 <code>handler</code> 保存的事件处理程序），用 <code>addEventListener</code>或 <code>attachEvent</code>绑定多次，如果第三个参数是相同的话，也只会被调用一次。当然，如果第三个参数一个设置为<code>true</code>，另一个设置为<code>false</code>，那么会被调用两次</p>
</blockquote>
<p><strong>事件委托的优点：</strong></p>
<ol>
<li><p>减少内存消耗<br>试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
  ......
  &lt;li&gt;item n&lt;/li&gt;
&lt;/ul&gt;
// ...... 代表中间还有未知数个 li</code></pre><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件的时候再去匹配判断目标元素；所以事件委托可以减少大量的内存消耗，节约效率</p>
<br />
</li>
<li><p>动态绑定事件<br>比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的</p>
</li>
</ol>
<h1 id="JavaScript-中-this-是如何工作的"><a href="#JavaScript-中-this-是如何工作的" class="headerlink" title="JavaScript 中 this 是如何工作的"></a>JavaScript 中 <code>this</code> 是如何工作的</h1><p>在JavaScript中<code>this</code>的指向总是让人很困惑，它到底指的是什么？为了彻底弄清它,我们就来探讨一下吧。<code>this</code>在不同的执行环境，不同的用法下会有所不同，以下分几种情况，讨论<code>this</code>的指向</p>
<p><strong>this在全局作用域中</strong>:</p>
<pre><code>// global scope

foo = &#39;abc&#39;;
alert(foo); // abc

this.foo = &#39;def&#39;;
alert(foo); // def</code></pre><p>在全局作用域/全局环境(global scope| global context)中，<code>this</code>指向的就是全局变量，所以上面代码中的<code>this.foo</code>其实就是全局中的<code>foo</code></p>
<ul>
<li>在浏览器里,指向<code>window</code>对象</li>
<li>在Node.js里，指向<code>global</code>对象</li>
</ul>
<br />

<p><strong>this在函数(function)里</strong>:</p>
<pre><code>var boat = {
    size: &#39;normal&#39;,
    boatInfo: function() {
        alert(this === boat);   
        alert(this.size);   
    }
};

boat.boatInfo(); // true, &#39;normal&#39;

var bigBoat = {
    size: &#39;big&#39;
};

bigBoat.boatInfo = boat.boatInfo;
bigBoat.boatInfo(); // false, &#39;big&#39;</code></pre><p>上面这段代码里，<code>this</code>本身是指向boat的，但是当我们创建一个新的对象，然后把<code>boat.boatInfo()</code>的方法赋给了它。然后我们调用<code>bigBoat.boatInfo()</code>,发现<code>this</code>不等于<code>boat</code>,<code>this.size</code>的值为big，<code>this</code>的指向改变了</p>
<blockquote>
<p>The first thing you must realise is that the value of this inside any function is never static, it is always determined every time you call a function, but before the function actually executes it’s code. The value of this inside a function is actually provided by the parent scope in which the function was called, and more importantly, how the actual function syntax was written.（<del>忘记哪本书上的了</del>）</p>
</blockquote>
<p>上面的意思大概就是，在任何函数中，<code>this</code>的指向都不是静态的(static)；它总是在你调用一个函数，但尚未执行函数内部代码前被指定；(查看参考链接中的执行环境的文章，这个阶段，实际就是初始化变量对象，在初始化变量对象的时候，确定了this的指向)实际上，this是被调用的函数的父作用域提供的，比如：<br>有一个巧妙的方法，当一个函数被调用时，应该立马看该作用域<code>()</code>左边的部分</p>
<ul>
<li><p>如果<code>()</code>左边是一个引用(reference),那么，函数的<code>this</code>指向的就是这个引用所属的对象</p>
</li>
<li><p>否则<code>this</code>指向的就是全局对象(window|global)</p>
<br />

</li>
</ul>
<p>我们来看一个简单的例子:</p>
<pre><code>function bar() {
    alert(this);
}
bar(); 
// 这里，this指向的是全局对象。我们先看()的左边，是bar,
// bar的左边是function，而function属于全局对象，所以this指向的就是全局对象

var foo = {
    baz: function() {
        alert(this);
    }
}
foo.baz(); 
// 这里,this指向的是foo,先看()左边是baz，baz是属于foo，所以baz里的this指向的就是foo</code></pre><br />

<p>我们再来看几个复杂的例子:</p>
<pre><code>var foo = {
    baz: function() {
        alert(this);
    }
}
foo.baz(); //这里this指向foo，因为()的左边是baz，而baz属于foo

var anotherBaz = foo.baz;
anotherBaz(); 
// 这里this指向全局对象，因为()左边是anotherBaz，znotherBaz（）是一个函数,函数属于全局对象</code></pre><pre><code>var anum = 0;

var foo = {
    anum: 10,
    baz: {
        anum: 20,
        bar: function() {
            console.log(this.anum);
        }
    }
}
foo.baz.bar(); // 20，因为()左边是bar，bar属于foo.baz，所以this就是foo.baz
,this.anum = foo.baz.anum = 20

var hello = foo.baz.bar;
hello(); // ()左边是hello，hello是一个函数，属于全局对象，所以this指向全局对
象，this.anum = window.anum = 0</code></pre><pre><code>const obj = {
  name: &#39;spike&#39;,
  friends: [&#39;deer&#39;, &#39;cat&#39;],
  loop: function() {
    this.friends.forEach( // ()左边是loop，而loop属于obj，所以这里的this指向obj
      function( friend ) {
        console.log(`${this.name} knows ${friend}`);
        console.log(this === global); // 在node.js环境下，全局对象为global
      }
    )
  }
}

obj.loop();
/*  可以看到，在forEach中的this并不是期待的那样指向obj，而是指向全局对象了  
**  也可以用上面提到的，还是看`()`左边，在forEach中，`()`左边是function，
**  function属于loop()，也是一个函数，而不是一个引用, 所以this指向的就是全局对
**  象
** 
**  所以这里的this.friends就是obj.friends this.name就是undfined
**
**  输出 
**  $ node test
**  undefined knows dear
**  true
**  undefined knows cat
*/  true</code></pre><br />

<p><strong>在构造函数里的this指向</strong>:<br>当使用<code>new</code>关键字去执行构造函数时，构造函数中的<code>this</code>指向的的就是新建的那个对象实例</p>
<pre><code>  var savedThis;
    function Constr() {
        // 保存构造函数中的this
        savedThis = this;
    }
    // 通过new关键字执行构造函数
    var inst = new Constr();

    // 构造函数中的this指向的就是新创建的对象实例inst
    console.log(savedThis === inst); // true</code></pre><p>如果你没有用<code>new</code>关键字去执行构造函数，那么就要分析函数被调用时所属的作用域了</p>
<pre><code>  function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    var p = Point(7, 5); // 没有用new关键字去执行构造函数！

    console.log(p === undefined); // 没有用new，所以构造函数没有返回一个实例 
    对象，所以 p === undefined

    // 没有用new关键字，Point(7,5);就只是把函数执行了一遍
    // ()左边是Point，属于全局对象，所以this指向全局对象
    console.log(x); // 7
    console.log(y); // 5</code></pre><br />

<p><strong>在事件处理器(event handler)中this的指向</strong>:</p>
<pre><code>&lt;div id=&quot;test&quot;&gt;I am an element with id #test&lt;/div&gt;

function doAlert() { 
    alert(this.innerHTML); 
} 

doAlert(); // undefined 
// doAlert()属于全局对象

var myElem = document.getElementById(&#39;test&#39;); 
myElem.onclick = doAlert; 

alert(myElem.onclick === doAlert); // true 
myElem.onclick(); // I am an element
// ()左边是onclick也就是doAlert,属于myElem,所以this指向myElem</code></pre><p>那个元素触发事件，this就指向那个元素</p>
<br />

<p><strong>总结</strong>:<br>  以上，对于函数中的<code>this</code>，通过查看<code>()</code>左边所属的对象去确定，真的很好用.<br>而实质上，<code>this</code>是在创建函数的执行环境时，在创建阶段确定的，因此，弄透执行环境，去思考执行环境创建阶段的<code>this</code>的指向，<code>this</code>的指向就不会弄错了.</p>
<h1 id="原型继承-prototypal-inheritance-的原理"><a href="#原型继承-prototypal-inheritance-的原理" class="headerlink" title="原型继承 (prototypal inheritance) 的原理"></a>原型继承 (prototypal inheritance) 的原理</h1><p>在 JavaScript 中，每个函数都有一个 prototype 属性，当这个函数被用作构造函数来创建实例时，这个函数的 prototype 属性值会被作为原型赋值给所有对象实例，也就是说，所有实例的原型引用的是函数的 prototype 属性<br>为了证明这一点,我们可以在 Chrome 控制台输入：</p>
<pre><code>function Person() {
}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true</code></pre><p>我们可以得到如下的关系图：<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1fg89af3vdaj30g0082t8x.jpg" alt="prototypal inheritance"></p>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<p>原型指向实例倒是没有，因为一个构造函数可以生成多个实例。但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数<br>让我们来验证一下：</p>
<pre><code>function Person() {
}
console.log(Person === Person.prototype.constructor); // true</code></pre><p>所以再更新下关系图：<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1fg89eran0aj30g4082dg5.jpg" alt="prototypal inheritance"></p>
<p><strong>属性查找</strong><br>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部（也就是 Object.prototype），如果仍然没有找到指定的属性，就会返回 undefined。</p>
<p>举个例子：</p>
<pre><code>function Person() {
}
Person.prototype.name = &#39;Kevin&#39;;
var person = new Person();
person.name = &#39;Daisy&#39;;
console.log(person.name) // Daisy
delete person.name;
console.log(person.name) // Kevin</code></pre><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin</p>
<p><strong>原型链</strong><br>同样，<code>person.prototype</code> 对象也有<code>__proto__</code>属性，它指向创建它的函数对象（Object）的 prototype</p>
<p><code>console.log(person.prototype.__proto__ === Object.prototype) //true</code></p>
<p>继续，<code>Object.prototype</code>对象也有 <code>__proto__</code>属性，但它比较特殊，为null</p>
<p><code>console.log(Object.prototype.__proto__) //null</code></p>
<p>我们把这个由 <code>__proto__</code> 串起来的直到 <code>Object.prototype.__proto__</code>为null的链叫做原型链</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1fg89mi2hv1j30ge0elt9d.jpg" alt="prototypal inheritancd"></p>
<p><strong>补充</strong><br>最后，补充两点可能不会注意的地方：</p>
<ul>
<li><strong>constructor</strong><pre><code>function Person() {
}
var person = new Person();
console.log(person.constructor === Person); // true</code></pre>当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</li>
</ul>
<p><code>person.constructor === Person.prototype.constructor</code></p>
<ul>
<li><strong><strong>proto</strong></strong></li>
</ul>
<p>其次是<code>__proto__</code>，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中。实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用<code>obj.__proto__</code>时，可以理解成返回了 Object.getPrototypeOf(obj)</p>
<h1 id="AMD-vs-CommonJS？"><a href="#AMD-vs-CommonJS？" class="headerlink" title="AMD vs. CommonJS？"></a>AMD vs. CommonJS？</h1><p>AMD和CommonJS是JavaScript的两种模块规范</p>
<p>在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载，然后，就可以调用模块提供的方法：</p>
<pre><code>var math = require(&#39;math&#39;);
math.add(2,3); // 5</code></pre><p>有了服务器端模块以后，很自然地，大家就想要客户端模块；而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行.</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境；还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<pre><code>var math = require(&#39;math&#39;);
math.add(2, 3);</code></pre><p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间；但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）；这就是AMD规范诞生的背景</p>
<p><strong>ADM</strong><br><strong>AMD</strong>是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”<br>它采用异步方式加载模块，模块的加载不影响它后面语句的运行;所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<br><code>require([module], callback);</code></p>
<ul>
<li>第一个参数<code>[module]</code>，是一个数组，里面的成员就是要加载的模块；</li>
<li>第二个参数callback，则是加载成功之后的回调函数<br>如果将前面的代码改写成AMD形式，就是下面这样：<pre><code>　require([&#39;math&#39;], function (math) {
　　　　math.add(2, 3);
　　});</code></pre>math.add()与math模块加载不是同步的，浏览器不会发生假死<br>所以很显然，AMD比较适合浏览器环境</li>
</ul>
<h1 id="请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式"><a href="#请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式" class="headerlink" title="请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式):"></a>请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式):</h1><p><code>function foo(){ }();</code></p>
<p>以function关键字开头的语句会被解析为函数声明，而函数声明是不允许直接运行的<br>原因：</p>
<ul>
<li>js”预编译”的特点:js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.</li>
<li>当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();故会报错</li>
<li>只有当解析器把这句话解析为函数表达式，才能够直接运行</li>
</ul>
<p>例如：</p>
<pre><code>(function foo(){
    // code..
})()</code></pre><h1 id="描述以下变量的区别：null，undefined-或-undeclared？该如何检测它们？"><a href="#描述以下变量的区别：null，undefined-或-undeclared？该如何检测它们？" class="headerlink" title="描述以下变量的区别：null，undefined 或 undeclared？该如何检测它们？"></a>描述以下变量的区别：<code>null</code>，<code>undefined</code> 或 <code>undeclared</code>？该如何检测它们？</h1><ul>
<li>undefined 为为定义</li>
<li>null 为一个空值</li>
</ul>
<p>typeof undefined 返回 undefined<br>typeof null 返回 object</p>
<h1 id="什么是闭包-closure-，如何使用它，为什么要使用它？"><a href="#什么是闭包-closure-，如何使用它，为什么要使用它？" class="headerlink" title="什么是闭包 (closure)，如何使用它，为什么要使用它？"></a>什么是闭包 (closure)，如何使用它，为什么要使用它？</h1><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”，就是能够读取其他函数内部变量的函数</p>
<p>闭包可以让这些变量的值始终保持在内存中，让我们可以读取函数内部的变量;所以在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁</p>
<p>闭包的特性：<br>1.函数内再嵌套函数<br>2.内部函数可以引用外层的参数和变量<br>3.参数和变量不会被垃圾回收机制回收</p>
<h1 id="请举出一个匿名函数的典型用例？"><a href="#请举出一个匿名函数的典型用例？" class="headerlink" title="请举出一个匿名函数的典型用例？"></a>请举出一个匿名函数的典型用例？</h1><p>匿名函数：就是没有函数名的函数，自执行匿名函数</p>
<ul>
<li>匿名函数的基本形式为（function（）{…}）（）;</li>
<li>前面的括号包含函数体，后面的括号就是给匿名函数传递参数并立即执行之</li>
<li>匿名函数的作用是用于闭包和避免变量的污染以及函数名的冲突</li>
</ul>
<p>举例说明：</p>
<pre><code>function func() {
  return function() {

  }
}

const func = function(){}

(function(){

})()</code></pre><p>用途：<br>        匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以嵌套命名空间，以减少变量的使用</p>
<p>作用域链的机制导致一个问题，<strong>在循环中里的匿名函数取得的任何变量都是最后一个值</strong></p>
<h1 id="你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"><a href="#你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？" class="headerlink" title="你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？"></a>你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？</h1><p>模块模式，一个IIFE就算是一个模块，互相之间不影响</p>
<pre><code>var jspy = (function() {
  var _count = 0;

  var incrementCount = function() {
    _count++;
  }

  var getCount = function() {
    return _count;
  }
  return {
    incrementCount: incrementCount,
    getCount: getCount
  };
})();  </code></pre><h1 id="请指出-JavaScript-宿主对象-host-objects-和原生对象-native-objects-的区别？"><a href="#请指出-JavaScript-宿主对象-host-objects-和原生对象-native-objects-的区别？" class="headerlink" title="请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？"></a>请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？</h1><ol>
<li><p><strong>原生对象：</strong></p>
<ul>
<li>独立于宿主环境的ECMAScript实现提供的对象</li>
<li>与宿主无关，在javascript（远景浏览器）、nodejs（node平台）、jscript（ie浏览器）、typescript（微软平台）等等中均有这些对象</li>
<li>简单来说，本地对象就是 ECMA-262 定义的类（引用类型），在运行过程中动态创建的对象，需要new<br />
</li>
</ul>
</li>
<li><p><strong>内置对象：</strong> </p>
<ul>
<li><p>由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现，即在引擎初始化阶段就被创建好的对象；这意味着开发者不必明确实例化内置对象，它已被实例化了 </p>
</li>
<li><p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）如此就可以理解了，内置对象是本地对象的一种</p>
<br />
</li>
</ul>
</li>
<li><p><strong>宿主对象：</strong></p>
<ul>
<li><p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”</p>
</li>
<li><p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义类对象，ECMAScript官方未定义的对象都属于宿主对象,所有非本地对象都是宿主对象</p>
</li>
<li><p>宿主提供对象原理==&gt;由宿主框架通过某种机制注册到ECscript引擎中的对象，如宿主浏览器（以远景为参考）会向ECscript注入window对象，构建其实现javascript。所有的BOM和DOM都是宿主对象。</p>
</li>
<li><p>说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象</p>
</li>
</ul>
</li>
</ol>
<h1 id="请指出以下代码的区别：function-Person-、var-person-Person-、var-person-new-Person"><a href="#请指出以下代码的区别：function-Person-、var-person-Person-、var-person-new-Person" class="headerlink" title="请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()"></a>请指出以下代码的区别：<code>function Person(){}</code>、<code>var person = Person()</code>、<code>var person = new Person()</code></h1><ul>
<li>第一个是定义了一个函数Person</li>
<li>第二个是把Person当普通函数执行，并把返回值赋值给person。</li>
<li>第三个是当做构造函数，通过new关键字创建一个实例对象，赋值给person </li>
</ul>
<h1 id="call-和-apply-的区别是什么"><a href="#call-和-apply-的区别是什么" class="headerlink" title=".call 和 .apply 的区别是什么"></a><code>.call</code> 和 <code>.apply</code> 的区别是什么</h1><p>.call和.apply存在的意义：<strong>改变函数执行时的上下文</strong>，再具体一点就是<strong>改变函数运行时的this指向</strong>.</p>
<p>ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已.</p>
<ol>
<li><strong><code>apply( )</code></strong><br>apply 方法传入两个参数：<br>一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组.<pre><code>var obj = {
 name : &#39;linxin&#39;
}
function func(firstName, lastName){
 console.log(firstName + &#39; &#39; + this.name + &#39; &#39; + lastName);
}
func.apply(obj, [&#39;A&#39;, &#39;B&#39;]);    // A linxin B</code></pre></li>
</ol>
<p>可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素.</p>
<ol start="2">
<li><strong><code>call( )</code></strong><br>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组.<pre><code>var obj = {
 name: &#39;linxin&#39;
}
function func(firstName, lastName) {
 console.log(firstName + &#39; &#39; + this.name + &#39; &#39; + lastName);
}
func.call(obj, &#39;C&#39;, &#39;D&#39;);       // C linxin D</code></pre></li>
</ol>
<p>对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中</p>
<p>对于什么时候该用什么方法，其实不用纠结；如果你的参数本来就存在一个数组中，那自然就用 apply；如果参数比较散乱相互之间没什么关联，就用 call.</p>
<ol start="3">
<li><strong><code>apply</code> 和 <code>call</code> 的用法</strong></li>
</ol>
<ul>
<li><ol>
<li>改变 this 指向</li>
</ol>
</li>
</ul>
<pre><code>var obj = {
    name: &#39;linxin&#39;
}
function func() {
    console.log(this.name);
}
func.call(obj);       // linxin</code></pre><p>我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象；此处 func 函数里其实相当于：</p>
<pre><code>function func() {
    console.log(obj.name);
}</code></pre><ul>
<li><ol start="2">
<li>借用别的对象的方法</li>
</ol>
</li>
</ul>
<p>先看例子</p>
<pre><code>var Person1  = function () {
    this.name = &#39;linxin&#39;;
}
var Person2 = function () {
    this.getname = function () {
        console.log(this.name);
    }
    Person1.call(this);
}
var person = new Person2();
person.getname();       // linxin</code></pre><p>从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name.<br>因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法.</p>
<ul>
<li><ol start="3">
<li>调用函数</li>
</ol>
</li>
</ul>
<p>apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数</p>
<pre><code>function func() {
    console.log(&#39;linxin&#39;);
}
func.call();            // linxin</code></pre><ol start="4">
<li><strong>call 和 bind 的区别</strong></li>
</ol>
<p>在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容.<br>它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数.</p>
<p>它们之间的区别有以下两点:</p>
<ul>
<li><ol>
<li>bind 返回值是函数<pre><code>var obj = {
name: &#39;linxin&#39;
}
function func() {
console.log(this.name);
}
var func1 = func.bind(obj);
func1();                        // linxin</code></pre>bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数；而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window.</li>
</ol>
</li>
<li><ol start="2">
<li>参数的使用</li>
</ol>
</li>
</ul>
<pre><code>function func(a, b, c) {
    console.log(a, b, c);
}
var func1 = func.bind(null,&#39;linxin&#39;);
func(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);            // A B C
func1(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;);           // linxin A B
func1(&#39;B&#39;, &#39;C&#39;);                // linxin B C
func.call(null, &#39;linxin&#39;);      // linxin undefined undefined</code></pre><p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排.</p>
<p>在低版本浏览器没有 bind 方法，我们也可以自己实现一个:</p>
<pre><code>if (!Function.prototype.bind) {
        Function.prototype.bind = function () {
            var self = this,                        // 保存原函数
                context = [].shift.call(arguments), // 保存需要绑定的this上下文
                args = [].slice.call(arguments);    // 剩余的参数转为数组
            return function () {                    // 返回一个新函数
                self.apply(context,[].concat.call(args, [].slice.call(arguments)));
            }
        }
    }</code></pre><h1 id="解释-Function-prototype-bind？"><a href="#解释-Function-prototype-bind？" class="headerlink" title="解释 Function.prototype.bind？"></a>解释 Function.prototype.bind？</h1><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用.</p>
<pre><code>const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
}

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42</code></pre><h1 id="在什么时候你会使用-document-write-？"><a href="#在什么时候你会使用-document-write-？" class="headerlink" title="在什么时候你会使用 document.write()？"></a>在什么时候你会使用 <code>document.write()</code>？</h1><p>DOM方法，可向文档写入 HTML 表达式或 JavaScript 代码</p>
<ul>
<li><p>加载需要配合JS脚本使用的外部CSS文件<br>将所有需要用到JS的样式都放到这个外部样式表中，如果浏览器不禁用JS，那么该样式<br>表就会被顺利加载，否则页面就不会使用该样式</p>
<pre><code>&lt;scirpt&gt;
document.write(&#39;&lt;link  rel=&quot;stylesheet&quot; href=&quot;style_neads_js.css&quot;&gt;&#39;);
&lt;/script&gt;</code></pre></li>
<li><p>在新的窗口中写入新的页面数据时<br>由于document.write会重写整个页面，异步调用会影响本页面的文档，如果在新窗口空<br>白页调用，就没影响了;新开一个窗口，把本页面取到的数据在新窗口展示:</p>
<pre><code>document.open();
document.write(&#39;anthing&#39;)
document.close();</code></pre><p>由于带来的弊端较多，一般不建议使用<br>要对DOM进行操作时，还是应当使用安全且对DOM的友好的API方法，以避免不必要的问题出现.</p>
</li>
</ul>
<blockquote>
<p>注：<br>document.write是直接将内容写入页面的内容流，会导致页面全部重绘<br>innerHTML将内容写入某个DOM节点，不会导致页面全部重绘</p>
</blockquote>
<h1 id="请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别"><a href="#请指出浏览器特性检测，特性推断和浏览器-UA-字符串嗅探的区别" class="headerlink" title="请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别"></a>请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别</h1><p>特性检测是指检测浏览器是否支持某个给定特性的过程，该方法是浏览器检测的首选方法</p>
<p>特性检测的模式很简单：首先检查特性是否存在，如果存在，就使用该特性.因此，使用一个if语句即可实现，如下所示：</p>
<pre><code>if(navigator.geolocation){
  //user geolocation
}</code></pre><p>上面的这种方式令人困惑，也给代码增加了歧义性.现在应尽量避免使用truthy/falsey语句，而是选择使用typeof运算符，如下所示：</p>
<pre><code>if(typeof  navigator.geolocation!=&quot;undefined&quot;){
        //use geolocation
    }</code></pre><p>浏览器嗅探<br>在大多数情况下，首选使用特性检测方法.因为浏览器嗅探方法具有许多缺陷</p>
<ul>
<li>其中之一就是少数浏览器可能宣称自己是某主流浏览器，其实并不是那种浏览器类型</li>
<li>另外一个问题是浏览器嗅探依赖于浏览器的userAgent字符串(user-agent string)，该字符串用于标识浏览器，且浏览器制造商可以在不同的版本之间进行大幅度的修改。仅挡针对其有古怪行为的单个浏览器时，才使用浏览器嗅探技术</li>
</ul>
<blockquote>
<p>navigator对象的appName属性和userAgent属性在标识浏览器方面很有用</p>
<ul>
<li>appName属性将返回浏览器的模型，如对IE返回Microsoft Internet Explorer,对Firefox,Chrome和Safari返回Netscape</li>
<li>userAgent属性返回一个包含多段信息的字符串，如浏览器的版本，操作系统和浏览器模型.但是，这个属性的返回值因浏览器而异.例如，浏览器的版本被嵌入在该字符串的不同位置</li>
</ul>
</blockquote>
<h1 id="请尽可能详尽的解释-Ajax-的工作原理"><a href="#请尽可能详尽的解释-Ajax-的工作原理" class="headerlink" title="请尽可能详尽的解释 Ajax 的工作原理"></a>请尽可能详尽的解释 Ajax 的工作原理</h1><p>Ajax的工作原理相当于在用户和服务器之间加了一个<strong>中间层(AJAX引擎)</strong>,使用户操作与服务器响应异步化，而且并不是所有的用户请求都提交给服务器,像一些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求</p>
<p>Ajax其核心有<code>JavaScript、XMLHTTPRequest、DOM</code>对象组成:</p>
<ol>
<li>通过<code>XmlHttpRequest对象</code>来向服务器发异步请求</li>
<li>然后<code>xhr对象</code>提供了一系列属性，可以监听响应的情况</li>
<li>然后从服务器获得数据</li>
<li>再用JavaScript来操作DOM而更新页面</li>
</ol>
<h1 id="请解释变量声明提升-hoisting"><a href="#请解释变量声明提升-hoisting" class="headerlink" title="请解释变量声明提升 (hoisting)"></a>请解释变量声明提升 (hoisting)</h1><p>“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准,实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中</p>
<p>JavaScript在执行任何代码段之前，将函数声明放入内存中的优点之一是你可以在声明一个函数之前使用该函数，列如:</p>
<pre><code>/**
* 正确的方式：先声明函数，再调用函数 (最佳实践)
*/
function catName(name) {
    console.log(&quot;我的猫名叫 &quot; + name);
}

catName(&quot;Tigger&quot;);

/*
以上代码的执行结果是: &quot;我的猫名叫 Tigger&quot;
*/</code></pre><p>上面的代码片按照是你的正常思维（先声明，后调用）去书写的<br>现在我们来看看当我们在写这个函数之前调用这个函数会发生什么：</p>
<pre><code>/**
* 不推荐的方式：先调用函数，再声明函数 
*/

catName(&quot;Chloe&quot;);

function catName(name) {
    console.log(&quot;我的猫名叫 &quot; + name);
}

/*
代码执行的结果是: &quot;我的猫名叫 Chloe&quot;
*/</code></pre><p>即使我们在定义这个函数之前调用它，函数仍然可以工作，这是因为在JavaScript中<strong>执行上下文</strong>的工作方式造成的.<br>变量提升也适用于其他数据类型和变量，变量可以在声明之前进行初始化和使用，但是如果没有初始化，就不能使用它们.</p>
<blockquote>
<p>注： 函数和变量相比，函数会被优先提升，这意味着函数会被提升到更靠前的位置</p>
</blockquote>
<pre><code>num = 6;
num + 7;
var num;
/* 没有给出错误，只要声明了num */</code></pre><p><strong>JavaScript 仅提升声明，而不提升初始化</strong>，如果你先使用的变量，再声明并初始化它，变量的值将是 undefined，以下两个示例演示了相同的行为：</p>
<pre><code>var x = 1;                 // 声明 + 初始化 x
console.log(x + &quot; &quot; + y);  // &#39;1 undefined&#39;
var y = 2;                 // 声明 + 初始化 y


//上面的代码和下面的代码是一样的 
var x = 1;                 // 声明 + 初始化 x
var y;                     //声明 y
console.log(x + &quot; &quot; + y);  //y 是未定义的
y = 2;                     // 初始化  y </code></pre><h1 id="“attribute”-和-“property”-的区别是什么？"><a href="#“attribute”-和-“property”-的区别是什么？" class="headerlink" title="“attribute” 和 “property” 的区别是什么？"></a>“attribute” 和 “property” 的区别是什么？</h1><ul>
<li>Attribute是原属性</li>
<li>Property是通过方法处理过得到的属性</li>
</ul>
<h1 id="为什么扩展-JavaScript-内置对象不是好的做法？"><a href="#为什么扩展-JavaScript-内置对象不是好的做法？" class="headerlink" title="为什么扩展 JavaScript 内置对象不是好的做法？"></a>为什么扩展 JavaScript 内置对象不是好的做法？</h1><ul>
<li><strong>扩展对象时，会更改其行为.</strong><br>更改只由您自己的代码使用的对象的行为是可以的，但是，当您更改其他代码也使用的某个代码的行为时，可能会破坏其他代码,当它在javascript中向对象和数组类添加方法时，由于javascript的工作方式，破坏某些东西的风险非常高</li>
</ul>
<h1 id="请指出-document-load-和-document-DOMContentLoaded-两个事件的区别"><a href="#请指出-document-load-和-document-DOMContentLoaded-两个事件的区别" class="headerlink" title="请指出 document load 和 document DOMContentLoaded 两个事件的区别"></a>请指出 document load 和 document DOMContentLoaded 两个事件的区别</h1><p>触发的时机不一样，先触发DOMContentLoaded事件（DOM树生成完成），后触发load事件（页面加载完成）</p>
<ul>
<li>DOMContentLoaded: DOM解析完成即触发此事件，不等待styles, images等资源的加载</li>
<li>load：依赖的资源也已加载完成</li>
</ul>
<p>DOM文档加载的步骤为:</p>
<pre><code>解析HTML结构
加载外部脚本和样式表文件
解析并执行脚本代码
DOM树构建完成  //DOMContentLoaded
加载图片等外部文件
页面加载完毕 //load</code></pre><p>用原生js可以这么写:</p>
<pre><code>// 不兼容老的浏览器，兼容写法见[jQuery中ready与load事件](http://www.imooc.com/
code/3253)，或用jQuery


document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
   // ...代码...
}, false);


window.addEventListener(&quot;load&quot;, function() {
    // ...代码...
}, false);</code></pre><p>用jQuery这么写:</p>
<pre><code>// DOMContentLoaded
$(document).ready(function() {
    // ...代码...
});

//load
$(document).load(function() {
    // ...代码...
});</code></pre><h1 id="和-有什么不同？"><a href="#和-有什么不同？" class="headerlink" title="== 和 === 有什么不同？"></a>== 和 === 有什么不同？</h1><p><strong>“===”叫做严格运算符，”==”叫做相等运算符</strong></p>
<ul>
<li><strong>严格运算符的运算规则如下:</strong></li>
</ul>
<p>(1)不同类型值<br>如果两个值的类型不同，直接返回false</p>
<p>(2)同一类的原始类型值<br>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false</p>
<p>(3)同一类的复合类型值<br>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象</p>
<p>(4)undefined和null<br>undefined 和 null 不严格相等,与自身严格相等</p>
<ul>
<li><strong>相等运算符在比较相同类型的数据时，与严格相等运算符完全一样:</strong></li>
</ul>
<p>(1)原始类型的值<br>原始类型的数据会转换成数值类型再进行比较</p>
<p>(2)对象与原始类型值比较<br>对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较</p>
<p>(3)undefined和null<br>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true</p>
<p>(4)相等运算符的缺点<br>相等运算符隐藏的类型转换，会带来一些违反直觉的结果</p>
<p><img src="https://pic1.zhimg.com/80/b922270259dece707ef6c6a50259a406_hd.jpg" alt="img"></p>
<ul>
<li>红色：===</li>
<li>橙色：==</li>
<li>黄色：&lt;= 和 &gt;= 同时成立，== 不成立</li>
<li>蓝色：只有 &gt;=</li>
<li>绿色：只有 &lt;=</li>
</ul>
<h1 id="请解释-JavaScript-的同源策略-same-origin-policy"><a href="#请解释-JavaScript-的同源策略-same-origin-policy" class="headerlink" title="请解释 JavaScript 的同源策略 (same-origin policy)"></a>请解释 JavaScript 的同源策略 (same-origin policy)</h1></div></div></article></div><div id="gitalk"></div><script>var gitalk = new Gitalk({
    clientID: '007c2e64322ff31b60e9',
    clientSecret: '889ab344b75944a36ccb79dff864e51063bfa5bd',
    id: '2019-12-30 10:10:10',
    repo: 'comments',
    owner: 'kikyoluka',
    admin: 'kikyoluka'
})
gitalk.render('gitalk')</script></div><div class="pjax-main-loading loading"><img class="loading-image" src="/images/loading.gif"></div></main><footer><div class="footer site-info"><p><i class="icon-copyright"></i><span>2018</span>&minus;<span>2020</span>&nbsp;&nbsp;&nbsp;<i class="icon-heart"></i>&nbsp;&nbsp;<span>琉花</span></p><p><a href="https://github.com/sanshiliuxiao/hexo-theme-aurora.git" target="_blank">hexo-theme-Aurora</a>&nbsp; | &nbsp;行至朝雾里 坠入暮云间</p></div></footer></div><div class="bg"><div class="pc-dynamic-bg"><span class="image" data-image="/images/theme/1.jpg"></span><span class="image" data-image="/images/theme/2.jpg"></span><span class="image" data-image="/images/theme/3.jpg"></span><span class="image" data-image="/images/theme/4.jpg"></span><span class="image" data-image="/images/theme/5.jpg"></span><span class="image" data-image="/images/theme/6.jpg"></span><span class="image" data-image="/images/theme/7.jpg"></span><span class="image" data-image="/images/theme/8.jpg"></span><span class="image" data-image="/images/theme/9.jpg"></span></div></div><span class="back-to-top"></span><div class="leancloud"><script src="/js/third-party/leancloud.min.js?version=2.0.0"></script><div class="leancloud-app-id" leancloud-app-id="LjOwR4ELEqbauKvtQbwq5TUw-MdYXbMMI"></div><div class="leancloud-app-key" leancloud-app-key="BOSFJ49ohbGctgn4zvJE9VN6"></div><div class="leancloud-app-hot"></div><div class="leancloud-app-visitor"></div></div><link rel="stylesheet" href="/lib/APlayer/APlayer.min.css"><script src="/lib/APlayer/APlayer.min.js"></script><div id="aplayer"></div><script>let list = JSON.parse('[{"name":"Julia，Train，Slow Down","artist":"Whale Fall","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/JuliaTrainSlowDown.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/5.jpg"},{"name":"The Wellwisher","artist":"Halves","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/TheWellwisher.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/4.jpg"},{"name":"SadSexy","artist":"Dirty Three","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/SadSexy .mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/1.jpg"},{"name":"Riverrun","artist":"Stubborn","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/Riverrun.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/3.jpg"},{"name":"Hortur","artist":"Picastro","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/Hortur.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/2.jpg"}]')
  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      theme: '#b28fce',
      audio: list,
      fixed: true,
      volume: 1
  });
  ap.list.show()
</script><script src="/js/third-party/jquery.min.js?version=2.0.0"></script><script src="/js/third-party/isMobile.min.js?version=2.0.0"></script><script src="/js/third-party/timeago.min.js?version=2.0.0"></script><script src="/js/third-party/pjax.min.js?version=2.0.0"></script><script src="/js/third-party/zooming.min.js?version=2.0.0"></script><script src="/js/third-party/backstretch.min.js?version=2.0.0"></script><script src="/js/highlight.min.js?version=2.0.0"></script><script src="/js/index.js?version=2.0.0"></script></body></html>
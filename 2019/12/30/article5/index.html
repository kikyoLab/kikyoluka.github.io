<!DOCTYPE html><html lang="ZH-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="author" content="琉花"><meta name="copyright" content="琉花"><meta name="og:image" content="/images/avatar.png"><meta name="og:type" content="website"><meta name="og:site_name" content="琉花"><meta name="og:url" content="kikyoluka.cn"><meta name="og：title" content="琉花"><meta name="theme-color" content="#b854d4" /><title>琉花</title><link rel="shortcut icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/index.css?version=2.0.0"><link rel="stylesheet" href="/font/fontello.css?version=2.0.0"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Mono|Noto+Serif+SC&amp;amp;display=swap"><link rel="canonical" href="//kikyoluka.cn"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script src="/lib/gitalk/gitalk.min.js"></script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="layout"><header><div class="header"><div class="mobile-bg" style="background-image:url(/images/mobile.png);"></div><h1 class="title">琉花</h1><h2 class="subtitle">行至朝雾里 坠入暮云间</h2><nav class="menu"><a class="menu-item pjax-main-link" href="/"><li><i class="icon-index"></i><span>首页</span></li></a><a class="menu-item pjax-main-link" href="/archives/"><li><i class="icon-archives"></i><span>归档</span></li></a><a class="menu-item pjax-main-link" href="/categories/"><li><i class="icon-categories"></i><span>分类</span></li></a><a class="menu-item pjax-main-link" href="/tags/"><li><i class="icon-tags"></i><span>标签</span></li></a><a class="menu-item pjax-main-link" href="/books/"><li><i class="icon-books"></i><span>书单</span></li></a><a class="menu-item pjax-main-link" href="/inspirations/"><li><i class="icon-inspiration"></i><span>灵感</span></li></a><a class="menu-item pjax-main-link" href="/friends/"><li><i class="icon-friends"></i><span>友链</span></li></a><a class="menu-item pjax-main-link" href="/about/"><li><i class="icon-about"></i><span>关于</span></li></a></nav></div></header><main><div class="main-wrapper"></div><div class="pjax-main-page"><div class="post"><article class="post-article"><div class="post-header"><img class="default-image" src="/images/postDefaultImage%20.png" style="opacity:0;"/><img class="post-image" src="https://cdn.jsdelivr.net/gh/chanshiyucx/yoi@latest/bg/21.jpg"/><div class="post-head"><div class="post-title-wrapper"><h1 class="post-title">前端面试题的整理-JS部分</h1><span class="post-image-source">pixiv</span></div><div class="post-meta"><span class="post-date"><i class="icon-calendar"></i><span class="date timeago" datetime="2019-12-30T02:10:10.000Z"></span></span><span class="post-hot"><i class="icon-fire"></i><span class="leancloud_visitors" id="/2019/12/30/article5/" data-flag-title="前端面试题的整理-JS部分">热度<span class="leancloud-visitors-count">0</span>℃</span></span><span class="post-tags"><i class="icon-tag"></i><span class="tag">面试知识</span></span><span class="post-categories"><i class="icon-bookmark-empty"></i><span class="category">笔记</span></span></div></div></div><div class="post-content"><div class="markdown"><h1 id="事件代理-event-delegation"><a href="#事件代理-event-delegation" class="headerlink" title="事件代理 (event delegation)"></a>事件代理 (event delegation)</h1><p>事件代理，即把一个元素响应事件（click、keydown……）的函数委托到另一个元素</p>
<p>一般来说会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p>
<p><strong>那么事件冒泡机制又是什么？</strong><br><strong>“DOM2级事件”规定事件流包括三个阶段</strong>，事件捕获阶段、处于目标阶段和事件冒泡阶段；<strong>首先发生的事件捕获</strong>，为截获事件提供了机会；然后是<strong>实际的目标接收了事件</strong>；最后一个阶段是<strong>冒泡阶段</strong>，可以在这个阶段对事件做出响应</p>
<ul>
<li><strong>事件捕获阶段</strong>：当鼠标点击或者触发dom事件时，浏览器会<strong>从根节点开始由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</li>
</ul>
<ul>
<li><strong>事件目标阶段</strong>：目标阶段就是指事件响应到触发事件的最底层元素上；</li>
</ul>
<ul>
<li><strong>事件冒泡阶段</strong>：冒泡阶段就是事件的触发响应会<strong>从最底层目标一层层地向外到最外层（根节点）</strong>，事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>
</ul>
<ol>
<li><p>事件捕获：<br><img src="https://segmentfault.com/img/remote/1460000012729086" alt="img"></p>
<br />
</li>
<li><p>事件冒泡:<br><img src="https://segmentfault.com/img/remote/1460000012729085" alt="img"></p>
<br />
</li>
<li><p>一个完整的事件流程：<br>从根节点开始一直到目标点，然后再从目标点到根节点<br><img src="https://pic1.zhimg.com/80/v2-4de189d2a42b1e8c74b379e067b67578_hd.jpg" alt="img"></p>
<br />

</li>
</ol>
<p><strong>说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent（<del>当然还有其它的事件绑定的方式这里不做介绍</del>）</strong></p>
<p><strong>addEventListener(event, listener, useCapture)</strong></p>
<p>参数定义：<br>event—（事件名称，如click，不带on）<br>listener—事件监听函数<br>useCapture—是否采用事件捕获进行事件捕捉（默认为false，即采用事件冒泡方式）<br>addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持</p>
<p>那么我们从代码上来看：</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;style&gt;
      #a{
          width: 300px;
          height: 300px;
          background: pink;
      }
      #b{
          width: 200px;
          height: 200px;
          background: blue;
      }
    #c{
        width: 100px;
        height: 100px;
        background: yellow;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;a&quot;&gt;
        &lt;div id=&quot;b&quot;&gt;
            &lt;div id=&quot;c&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;script&gt;
      var a = document.getElementById(&quot;a&quot;),
          b = document.getElementById(&quot;b&quot;),
          c = document.getElementById(&quot;c&quot;);

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c1&quot;);
          // 注意第三个参数没有传进 false , 因为默认传进来的是 false
          //，代表冒泡阶段调用，个人认为处于目标阶段也会调用的
      });

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c2&quot;);
      }, true);

      b.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;b&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a1&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a2&quot;)
      });

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a3&quot;);
          event.stopImmediatePropagation();
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a4&quot;);
      }, true);
  &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li><p>在这个代码中，如果点击c和b的话，根据DOM事件流，应该先从事件捕获开始，那么自然就是从a开始往目标事件进行事件捕获；而代码中只有a1、a3、a4为捕获阶段（因为其addEventListener的第三个参数为true，默认为false–即采用事件冒泡方式），但是a3的event.stopImmediatePropagation();阻止事件的传播（捕获或冒泡），同时也阻止该元素上后来绑定的事件处理程序被调用，所以整个代码就直接被结束了，故只输出a1、a3</p>
<br />
</li>
<li><p>如果点击a的话，目标事件就在a，事件流既不属于捕获也不属于冒泡，事件流处于目标阶段，所以直接按顺序输出a1、a2、a3</p>
<br />
</li>
<li><p>如果注释掉event.stopImmediatePropagation();再点击c的话，从捕获开始a1、a3、a4、b然后到目标阶段c1、c2然后到冒泡阶段a2</p>
<br />

</li>
</ul>
<blockquote>
<p>为什么冒泡阶段不全部再触发一次呢？因为如果同一个事件处理程序（指针相同，比如用 <code>handler</code> 保存的事件处理程序），用 <code>addEventListener</code>或 <code>attachEvent</code>绑定多次，如果第三个参数是相同的话，也只会被调用一次。当然，如果第三个参数一个设置为<code>true</code>，另一个设置为<code>false</code>，那么会被调用两次</p>
</blockquote>
<p><strong>事件委托的优点：</strong></p>
<ol>
<li><p>减少内存消耗<br>试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
  ......
  &lt;li&gt;item n&lt;/li&gt;
&lt;/ul&gt;
// ...... 代表中间还有未知数个 li</code></pre><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件的时候再去匹配判断目标元素；所以事件委托可以减少大量的内存消耗，节约效率</p>
<br />
</li>
<li><p>动态绑定事件<br>比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的</p>
</li>
</ol>
<h1 id="JavaScript-中-this-是如何工作的"><a href="#JavaScript-中-this-是如何工作的" class="headerlink" title="JavaScript 中 this 是如何工作的"></a>JavaScript 中 <code>this</code> 是如何工作的</h1><p>在JavaScript中<code>this</code>的指向总是让人很困惑，它到底指的是什么？为了彻底弄清它,我们就来探讨一下吧。<code>this</code>在不同的执行环境，不同的用法下会有所不同，以下分几种情况，讨论<code>this</code>的指向</p>
<p><strong>this在全局作用域中</strong>:</p>
<pre><code>// global scope

foo = &#39;abc&#39;;
alert(foo); // abc

this.foo = &#39;def&#39;;
alert(foo); // def</code></pre><p>在全局作用域/全局环境(global scope| global context)中，<code>this</code>指向的就是全局变量，所以上面代码中的<code>this.foo</code>其实就是全局中的<code>foo</code></p>
<ul>
<li>在浏览器里,指向<code>window</code>对象</li>
<li>在Node.js里，指向<code>global</code>对象</li>
</ul>
<br />

<p><strong>this在函数(function)里</strong>:</p>
<pre><code>var boat = {
    size: &#39;normal&#39;,
    boatInfo: function() {
        alert(this === boat);   
        alert(this.size);   
    }
};

boat.boatInfo(); // true, &#39;normal&#39;

var bigBoat = {
    size: &#39;big&#39;
};

bigBoat.boatInfo = boat.boatInfo;
bigBoat.boatInfo(); // false, &#39;big&#39;</code></pre><p>上面这段代码里，<code>this</code>本身是指向boat的，但是当我们创建一个新的对象，然后把<code>boat.boatInfo()</code>的方法赋给了它。然后我们调用<code>bigBoat.boatInfo()</code>,发现<code>this</code>不等于<code>boat</code>,<code>this.size</code>的值为big，<code>this</code>的指向改变了</p>
<blockquote>
<p>The first thing you must realise is that the value of this inside any function is never static, it is always determined every time you call a function, but before the function actually executes it’s code. The value of this inside a function is actually provided by the parent scope in which the function was called, and more importantly, how the actual function syntax was written.（<del>忘记哪本书上的了</del>）</p>
</blockquote>
<p>上面的意思大概就是，在任何函数中，<code>this</code>的指向都不是静态的(static)；它总是在你调用一个函数，但尚未执行函数内部代码前被指定；(查看参考链接中的执行环境的文章，这个阶段，实际就是初始化变量对象，在初始化变量对象的时候，确定了this的指向)实际上，this是被调用的函数的父作用域提供的，比如：<br>有一个巧妙的方法，当一个函数被调用时，应该立马看该作用域<code>()</code>左边的部分</p>
<ul>
<li><p>如果<code>()</code>左边是一个引用(reference),那么，函数的<code>this</code>指向的就是这个引用所属的对象</p>
</li>
<li><p>否则<code>this</code>指向的就是全局对象(window|global)</p>
<br />

</li>
</ul>
<p>我们来看一个简单的例子:</p>
<pre><code>function bar() {
    alert(this);
}
bar(); 
// 这里，this指向的是全局对象。我们先看()的左边，是bar,
// bar的左边是function，而function属于全局对象，所以this指向的就是全局对象

var foo = {
    baz: function() {
        alert(this);
    }
}
foo.baz(); 
// 这里,this指向的是foo,先看()左边是baz，baz是属于foo，所以baz里的this指向的就是foo</code></pre><br />

<p>我们再来看几个复杂的例子:</p>
<pre><code>var foo = {
    baz: function() {
        alert(this);
    }
}
foo.baz(); //这里this指向foo，因为()的左边是baz，而baz属于foo

var anotherBaz = foo.baz;
anotherBaz(); 
// 这里this指向全局对象，因为()左边是anotherBaz，znotherBaz（）是一个函数,函数属于全局对象</code></pre><pre><code>var anum = 0;

var foo = {
    anum: 10,
    baz: {
        anum: 20,
        bar: function() {
            console.log(this.anum);
        }
    }
}
foo.baz.bar(); // 20，因为()左边是bar，bar属于foo.baz，所以this就是foo.baz
,this.anum = foo.baz.anum = 20

var hello = foo.baz.bar;
hello(); // ()左边是hello，hello是一个函数，属于全局对象，所以this指向全局对
象，this.anum = window.anum = 0</code></pre><pre><code>const obj = {
  name: &#39;spike&#39;,
  friends: [&#39;deer&#39;, &#39;cat&#39;],
  loop: function() {
    this.friends.forEach( // ()左边是loop，而loop属于obj，所以这里的this指向obj
      function( friend ) {
        console.log(`${this.name} knows ${friend}`);
        console.log(this === global); // 在node.js环境下，全局对象为global
      }
    )
  }
}

obj.loop();
/*  可以看到，在forEach中的this并不是期待的那样指向obj，而是指向全局对象了  
**  也可以用上面提到的，还是看`()`左边，在forEach中，`()`左边是function，
**  function属于loop()，也是一个函数，而不是一个引用, 所以this指向的就是全局对
**  象
** 
**  所以这里的this.friends就是obj.friends this.name就是undfined
**
**  输出 
**  $ node test
**  undefined knows dear
**  true
**  undefined knows cat
*/  true</code></pre><br />

<p><strong>在构造函数里的this指向</strong>:<br>当使用<code>new</code>关键字去执行构造函数时，构造函数中的<code>this</code>指向的的就是新建的那个对象实例</p>
<pre><code>  var savedThis;
    function Constr() {
        // 保存构造函数中的this
        savedThis = this;
    }
    // 通过new关键字执行构造函数
    var inst = new Constr();

    // 构造函数中的this指向的就是新创建的对象实例inst
    console.log(savedThis === inst); // true</code></pre><p>如果你没有用<code>new</code>关键字去执行构造函数，那么就要分析函数被调用时所属的作用域了</p>
<pre><code>  function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    var p = Point(7, 5); // 没有用new关键字去执行构造函数！

    console.log(p === undefined); // 没有用new，所以构造函数没有返回一个实例 
    对象，所以 p === undefined

    // 没有用new关键字，Point(7,5);就只是把函数执行了一遍
    // ()左边是Point，属于全局对象，所以this指向全局对象
    console.log(x); // 7
    console.log(y); // 5</code></pre><br />

<p><strong>在事件处理器(event handler)中this的指向</strong>:</p>
<pre><code>&lt;div id=&quot;test&quot;&gt;I am an element with id #test&lt;/div&gt;

function doAlert() { 
    alert(this.innerHTML); 
} 

doAlert(); // undefined 
// doAlert()属于全局对象

var myElem = document.getElementById(&#39;test&#39;); 
myElem.onclick = doAlert; 

alert(myElem.onclick === doAlert); // true 
myElem.onclick(); // I am an element
// ()左边是onclick也就是doAlert,属于myElem,所以this指向myElem</code></pre><p>那个元素触发事件，this就指向那个元素</p>
<br />

<p><strong>总结</strong>:<br>  以上，对于函数中的<code>this</code>，通过查看<code>()</code>左边所属的对象去确定，真的很好用.<br>而实质上，<code>this</code>是在创建函数的执行环境时，在创建阶段确定的，因此，弄透执行环境，去思考执行环境创建阶段的<code>this</code>的指向，<code>this</code>的指向就不会弄错了.</p>
<h1 id="原型继承-prototypal-inheritance-的原理"><a href="#原型继承-prototypal-inheritance-的原理" class="headerlink" title="原型继承 (prototypal inheritance) 的原理"></a>原型继承 (prototypal inheritance) 的原理</h1><p>在 JavaScript 中，每个函数都有一个 prototype 属性，当这个函数被用作构造函数来创建实例时，这个函数的 prototype 属性值会被作为原型赋值给所有对象实例，也就是说，所有实例的原型引用的是函数的 prototype 属性<br>为了证明这一点,我们可以在 Chrome 控制台输入：</p>
<pre><code>function Person() {
}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true</code></pre><p>我们可以得到如下的关系图：<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1fg89af3vdaj30g0082t8x.jpg" alt="prototypal inheritance"></p>
<p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p>
<p>原型指向实例倒是没有，因为一个构造函数可以生成多个实例。但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数<br>让我们来验证一下：</p>
<pre><code>function Person() {
}
console.log(Person === Person.prototype.constructor); // true</code></pre><p>所以再更新下关系图：<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1fg89eran0aj30g4082dg5.jpg" alt="prototypal inheritance"></p>
<p><strong>属性查找</strong><br>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部（也就是 Object.prototype），如果仍然没有找到指定的属性，就会返回 undefined。</p>
<p>举个例子：</p>
<pre><code>function Person() {
}
Person.prototype.name = &#39;Kevin&#39;;
var person = new Person();
person.name = &#39;Daisy&#39;;
console.log(person.name) // Daisy
delete person.name;
console.log(person.name) // Kevin</code></pre><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy</p>
<p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin</p>
<p><strong>原型链</strong><br>同样，<code>person.prototype</code> 对象也有<code>__proto__</code>属性，它指向创建它的函数对象（Object）的 prototype</p>
<p><code>console.log(person.prototype.__proto__ === Object.prototype) //true</code></p>
<p>继续，<code>Object.prototype</code>对象也有 <code>__proto__</code>属性，但它比较特殊，为null</p>
<p><code>console.log(Object.prototype.__proto__) //null</code></p>
<p>我们把这个由 <code>__proto__</code> 串起来的直到 <code>Object.prototype.__proto__</code>为null的链叫做原型链</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1fg89mi2hv1j30ge0elt9d.jpg" alt="prototypal inheritancd"></p>
<p><strong>补充</strong><br>最后，补充两点可能不会注意的地方：</p>
<ul>
<li><strong>constructor</strong><pre><code>function Person() {
}
var person = new Person();
console.log(person.constructor === Person); // true</code></pre>当获取 person.constructor 时，其实 person 中并没有 constructor 属性，当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</li>
</ul>
<p><code>person.constructor === Person.prototype.constructor</code></p>
<ul>
<li><strong><strong>proto</strong></strong></li>
</ul>
<p>其次是<code>__proto__</code>，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中。实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用<code>obj.__proto__</code>时，可以理解成返回了 Object.getPrototypeOf(obj)</p>
<h1 id="AMD-vs-CommonJS？"><a href="#AMD-vs-CommonJS？" class="headerlink" title="AMD vs. CommonJS？"></a>AMD vs. CommonJS？</h1><p>AMD和CommonJS是JavaScript的两种模块规范</p>
<p>在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载，然后，就可以调用模块提供的方法：</p>
<pre><code>var math = require(&#39;math&#39;);
math.add(2,3); // 5</code></pre><p>有了服务器端模块以后，很自然地，大家就想要客户端模块；而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行.</p>
<p>但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境；还是上一节的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p>
<pre><code>var math = require(&#39;math&#39;);
math.add(2, 3);</code></pre><p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间；但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）；这就是AMD规范诞生的背景</p>
<p><strong>ADM</strong><br><strong>AMD</strong>是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”<br>它采用异步方式加载模块，模块的加载不影响它后面语句的运行;所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行</p>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：<br><code>require([module], callback);</code></p>
<ul>
<li>第一个参数<code>[module]</code>，是一个数组，里面的成员就是要加载的模块；</li>
<li>第二个参数callback，则是加载成功之后的回调函数<br>如果将前面的代码改写成AMD形式，就是下面这样：<pre><code>　require([&#39;math&#39;], function (math) {
　　　　math.add(2, 3);
　　});</code></pre>math.add()与math模块加载不是同步的，浏览器不会发生假死<br>所以很显然，AMD比较适合浏览器环境</li>
</ul>
<h1 id="请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式"><a href="#请解释为什么接下来这段代码不是-IIFE-立即调用的函数表达式" class="headerlink" title="请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式):"></a>请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式):</h1><p><code>function foo(){ }();</code></p>
<p>以function关键字开头的语句会被解析为函数声明，而函数声明是不允许直接运行的<br>原因：</p>
<ul>
<li>js”预编译”的特点:js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.</li>
<li>当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();故会报错</li>
<li>只有当解析器把这句话解析为函数表达式，才能够直接运行</li>
</ul>
<p>例如：</p>
<pre><code>(function foo(){
    // code..
})()</code></pre><h1 id="描述以下变量的区别：null，undefined-或-undeclared？该如何检测它们？"><a href="#描述以下变量的区别：null，undefined-或-undeclared？该如何检测它们？" class="headerlink" title="描述以下变量的区别：null，undefined 或 undeclared？该如何检测它们？"></a>描述以下变量的区别：<code>null</code>，<code>undefined</code> 或 <code>undeclared</code>？该如何检测它们？</h1><ul>
<li>undefined 为为定义</li>
<li>null 为一个空值</li>
</ul>
<p>typeof undefined 返回 undefined<br>typeof null 返回 object</p>
<h1 id="什么是闭包-closure-，如何使用它，为什么要使用它？"><a href="#什么是闭包-closure-，如何使用它，为什么要使用它？" class="headerlink" title="什么是闭包 (closure)，如何使用它，为什么要使用它？"></a>什么是闭包 (closure)，如何使用它，为什么要使用它？</h1><p>未完待续……</p>
</div></div></article></div><div id="gitalk"></div><script>var gitalk = new Gitalk({
    clientID: '007c2e64322ff31b60e9',
    clientSecret: '889ab344b75944a36ccb79dff864e51063bfa5bd',
    id: '2019-12-30 10:10:10',
    repo: 'comments',
    owner: 'kikyoluka',
    admin: 'kikyoluka'
})
gitalk.render('gitalk')</script></div><div class="pjax-main-loading loading"><img class="loading-image" src="/images/loading.gif"></div></main><footer><div class="footer site-info"><p><i class="icon-copyright"></i><span>2018</span>&minus;<span>2020</span>&nbsp;&nbsp;&nbsp;<i class="icon-heart"></i>&nbsp;&nbsp;<span>琉花</span></p><p><a href="https://github.com/sanshiliuxiao/hexo-theme-aurora.git" target="_blank">hexo-theme-Aurora</a>&nbsp; | &nbsp;行至朝雾里 坠入暮云间</p></div></footer></div><div class="bg"><div class="pc-dynamic-bg"><span class="image" data-image="/images/theme/1.jpg"></span><span class="image" data-image="/images/theme/2.jpg"></span><span class="image" data-image="/images/theme/3.jpg"></span><span class="image" data-image="/images/theme/4.jpg"></span><span class="image" data-image="/images/theme/5.jpg"></span><span class="image" data-image="/images/theme/6.jpg"></span><span class="image" data-image="/images/theme/7.jpg"></span><span class="image" data-image="/images/theme/8.jpg"></span><span class="image" data-image="/images/theme/9.jpg"></span></div></div><span class="back-to-top"></span><div class="leancloud"><script src="/js/third-party/leancloud.min.js?version=2.0.0"></script><div class="leancloud-app-id" leancloud-app-id="LjOwR4ELEqbauKvtQbwq5TUw-MdYXbMMI"></div><div class="leancloud-app-key" leancloud-app-key="BOSFJ49ohbGctgn4zvJE9VN6"></div><div class="leancloud-app-hot"></div><div class="leancloud-app-visitor"></div></div><link rel="stylesheet" href="/lib/APlayer/APlayer.min.css"><script src="/lib/APlayer/APlayer.min.js"></script><div id="aplayer"></div><script>let list = JSON.parse('[{"name":"Julia，Train，Slow Down","artist":"Whale Fall","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/JuliaTrainSlowDown.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/5.jpg"},{"name":"The Wellwisher","artist":"Halves","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/TheWellwisher.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/4.jpg"},{"name":"SadSexy","artist":"Dirty Three","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/SadSexy .mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/1.jpg"},{"name":"Riverrun","artist":"Stubborn","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/Riverrun.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/3.jpg"},{"name":"Hortur","artist":"Picastro","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/Hortur.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/2.jpg"}]')
  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      theme: '#b28fce',
      audio: list,
      fixed: true,
      volume: 1
  });
  ap.list.show()
</script><script src="/js/third-party/jquery.min.js?version=2.0.0"></script><script src="/js/third-party/isMobile.min.js?version=2.0.0"></script><script src="/js/third-party/timeago.min.js?version=2.0.0"></script><script src="/js/third-party/pjax.min.js?version=2.0.0"></script><script src="/js/third-party/zooming.min.js?version=2.0.0"></script><script src="/js/third-party/backstretch.min.js?version=2.0.0"></script><script src="/js/highlight.min.js?version=2.0.0"></script><script src="/js/index.js?version=2.0.0"></script></body></html>
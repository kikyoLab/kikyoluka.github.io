<!DOCTYPE html><html lang="ZH-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="referrer" content="no-referrer"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no,viewport-fit=cover"><meta name="author" content="琉花"><meta name="copyright" content="琉花"><meta name="og:image" content="/images/avatar.png"><meta name="og:type" content="website"><meta name="og:site_name" content="琉花"><meta name="og:url" content="kikyoluka.cn"><meta name="og：title" content="琉花"><meta name="theme-color" content="#b854d4" /><title>琉花</title><link rel="shortcut icon" href="/images/favicon.jpg" type="image/x-icon"><link rel="stylesheet" href="/css/index.css?version=2.0.0"><link rel="stylesheet" href="/font/fontello.css?version=2.0.0"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Mono|Noto+Serif+SC&amp;amp;display=swap"><link rel="canonical" href="//kikyoluka.cn"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script src="/lib/gitalk/gitalk.min.js"></script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="layout"><header><div class="header"><div class="mobile-bg" style="background-image:url(/images/mobile.png);"></div><h1 class="title">琉花</h1><h2 class="subtitle">行至朝雾里 坠入暮云间</h2><nav class="menu"><a class="menu-item pjax-main-link" href="/"><li><i class="icon-index"></i><span>首页</span></li></a><a class="menu-item pjax-main-link" href="/archives/"><li><i class="icon-archives"></i><span>归档</span></li></a><a class="menu-item pjax-main-link" href="/categories/"><li><i class="icon-categories"></i><span>分类</span></li></a><a class="menu-item pjax-main-link" href="/tags/"><li><i class="icon-tags"></i><span>标签</span></li></a><a class="menu-item pjax-main-link" href="/books/"><li><i class="icon-books"></i><span>书单</span></li></a><a class="menu-item pjax-main-link" href="/inspirations/"><li><i class="icon-inspiration"></i><span>灵感</span></li></a><a class="menu-item pjax-main-link" href="/friends/"><li><i class="icon-friends"></i><span>友链</span></li></a><a class="menu-item pjax-main-link" href="/about/"><li><i class="icon-about"></i><span>关于</span></li></a></nav></div></header><main><div class="main-wrapper"></div><div class="pjax-main-page"><div class="post"><article class="post-article"><div class="post-header"><img class="default-image" src="/images/postDefaultImage%20.png" style="opacity:0;"/><img class="post-image" src="https://cdn.jsdelivr.net/gh/chanshiyucx/yoi@latest/bg/21.jpg"/><div class="post-head"><div class="post-title-wrapper"><h1 class="post-title">前端面试题的整理-JS部分</h1><span class="post-image-source">pixiv</span></div><div class="post-meta"><span class="post-date"><i class="icon-calendar"></i><span class="date timeago" datetime="2019-12-30T02:10:10.000Z"></span></span><span class="post-hot"><i class="icon-fire"></i><span class="leancloud_visitors" id="/2019/12/30/article5/" data-flag-title="前端面试题的整理-JS部分">热度<span class="leancloud-visitors-count">0</span>℃</span></span><span class="post-tags"><i class="icon-tag"></i><span class="tag">面试知识</span></span><span class="post-categories"><i class="icon-bookmark-empty"></i><span class="category">笔记</span></span></div></div></div><div class="post-content"><div class="markdown"><h1 id="事件代理-event-delegation"><a href="#事件代理-event-delegation" class="headerlink" title="事件代理 (event delegation)"></a>事件代理 (event delegation)</h1><p>事件代理，即把一个元素响应事件（click、keydown……）的函数委托到另一个元素</p>
<p>一般来说会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数</p>
<p><strong>那么事件冒泡机制又是什么？</strong><br><strong>“DOM2级事件”规定事件流包括三个阶段</strong>，事件捕获阶段、处于目标阶段和事件冒泡阶段；<strong>首先发生的事件捕获</strong>，为截获事件提供了机会；然后是<strong>实际的目标接收了事件</strong>；最后一个阶段是<strong>冒泡阶段</strong>，可以在这个阶段对事件做出响应</p>
<ul>
<li><strong>事件捕获阶段</strong>：当鼠标点击或者触发dom事件时，浏览器会<strong>从根节点开始由外到内</strong>进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件</li>
</ul>
<ul>
<li><strong>事件目标阶段</strong>：目标阶段就是指事件响应到触发事件的最底层元素上；</li>
</ul>
<ul>
<li><strong>事件冒泡阶段</strong>：冒泡阶段就是事件的触发响应会<strong>从最底层目标一层层地向外到最外层（根节点）</strong>，事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</li>
</ul>
<ol>
<li><p>事件捕获：<br><img src="https://segmentfault.com/img/remote/1460000012729086" alt="img"></p>
<br />
</li>
<li><p>事件冒泡:<br><img src="https://segmentfault.com/img/remote/1460000012729085" alt="img"></p>
<br />
</li>
<li><p>一个完整的事件流程：<br>从根节点开始一直到目标点，然后再从目标点到根节点<br><img src="https://pic1.zhimg.com/80/v2-4de189d2a42b1e8c74b379e067b67578_hd.jpg" alt="img"></p>
<br />

</li>
</ol>
<p><strong>说到事件冒泡与捕获就不得不提一下两个用于事件绑定的方法addEventListener、attachEvent（<del>当然还有其它的事件绑定的方式这里不做介绍</del>）</strong></p>
<p><strong>addEventListener(event, listener, useCapture)</strong></p>
<p>参数定义：<br>event—（事件名称，如click，不带on）<br>listener—事件监听函数<br>useCapture—是否采用事件捕获进行事件捕捉（默认为false，即采用事件冒泡方式）<br>addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持</p>
<p>那么我们从代码上来看：</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;style&gt;
      #a{
          width: 300px;
          height: 300px;
          background: pink;
      }
      #b{
          width: 200px;
          height: 200px;
          background: blue;
      }
    #c{
        width: 100px;
        height: 100px;
        background: yellow;
    }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;a&quot;&gt;
        &lt;div id=&quot;b&quot;&gt;
            &lt;div id=&quot;c&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
  &lt;script&gt;
      var a = document.getElementById(&quot;a&quot;),
          b = document.getElementById(&quot;b&quot;),
          c = document.getElementById(&quot;c&quot;);

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c1&quot;);
          // 注意第三个参数没有传进 false , 因为默认传进来的是 false
          //，代表冒泡阶段调用，个人认为处于目标阶段也会调用的
      });

      c.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;c2&quot;);
      }, true);

      b.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;b&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a1&quot;);
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a2&quot;)
      });

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a3&quot;);
          event.stopImmediatePropagation();
      }, true);

      a.addEventListener(&quot;click&quot;, function (event) {
          console.log(&quot;a4&quot;);
      }, true);
  &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><ul>
<li><p>在这个代码中，如果点击c和b的话，根据DOM事件流，应该先从事件捕获开始，那么自然就是从a开始往目标事件进行事件捕获；而代码中只有a1、a3、a4为捕获阶段（因为其addEventListener的第三个参数为true，默认为false–即采用事件冒泡方式），但是a3的event.stopImmediatePropagation();阻止事件的传播（捕获或冒泡），同时也阻止该元素上后来绑定的事件处理程序被调用，所以整个代码就直接被结束了，故只输出a1、a3</p>
<br />
</li>
<li><p>如果点击a的话，目标事件就在a，事件流既不属于捕获也不属于冒泡，事件流处于目标阶段，所以直接按顺序输出a1、a2、a3</p>
<br />
</li>
<li><p>如果注释掉event.stopImmediatePropagation();再点击c的话，从捕获开始a1、a3、a4、b然后到目标阶段c1、c2然后到冒泡阶段a2</p>
<br />

</li>
</ul>
<blockquote>
<p>为什么冒泡阶段不全部再触发一次呢？因为如果同一个事件处理程序（指针相同，比如用 <code>handler</code> 保存的事件处理程序），用 <code>addEventListener</code>或 <code>attachEvent</code>绑定多次，如果第三个参数是相同的话，也只会被调用一次。当然，如果第三个参数一个设置为<code>true</code>，另一个设置为<code>false</code>，那么会被调用两次</p>
</blockquote>
<p><strong>事件委托的优点：</strong></p>
<ol>
<li><p>减少内存消耗<br>试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
  ......
  &lt;li&gt;item n&lt;/li&gt;
&lt;/ul&gt;
// ...... 代表中间还有未知数个 li</code></pre><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 <code>ul</code> 上，然后在执行事件的时候再去匹配判断目标元素；所以事件委托可以减少大量的内存消耗，节约效率</p>
<br />
</li>
<li><p>动态绑定事件<br>比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的</p>
</li>
</ol>
<h1 id="JavaScript-中-this-是如何工作的"><a href="#JavaScript-中-this-是如何工作的" class="headerlink" title="JavaScript 中 this 是如何工作的"></a>JavaScript 中 <code>this</code> 是如何工作的</h1><p>  未完待续…</p>
</div></div></article></div><div id="gitalk"></div><script>var gitalk = new Gitalk({
    clientID: '007c2e64322ff31b60e9',
    clientSecret: '889ab344b75944a36ccb79dff864e51063bfa5bd',
    id: '2019-12-30 10:10:10',
    repo: 'comments',
    owner: 'kikyoluka',
    admin: 'kikyoluka'
})
gitalk.render('gitalk')</script></div><div class="pjax-main-loading loading"><img class="loading-image" src="/images/loading.gif"></div></main><footer><div class="footer site-info"><p><i class="icon-copyright"></i><span>2018</span>&minus;<span>2020</span>&nbsp;&nbsp;&nbsp;<i class="icon-heart"></i>&nbsp;&nbsp;<span>琉花</span></p><p><a href="https://github.com/sanshiliuxiao/hexo-theme-aurora.git" target="_blank">hexo-theme-Aurora</a>&nbsp; | &nbsp;行至朝雾里 坠入暮云间</p></div></footer></div><div class="bg"><div class="pc-dynamic-bg"><span class="image" data-image="/images/theme/1.jpg"></span><span class="image" data-image="/images/theme/2.jpg"></span><span class="image" data-image="/images/theme/3.jpg"></span><span class="image" data-image="/images/theme/4.jpg"></span><span class="image" data-image="/images/theme/5.jpg"></span><span class="image" data-image="/images/theme/6.jpg"></span><span class="image" data-image="/images/theme/7.jpg"></span><span class="image" data-image="/images/theme/8.jpg"></span><span class="image" data-image="/images/theme/9.jpg"></span></div></div><span class="back-to-top"></span><div class="leancloud"><script src="/js/third-party/leancloud.min.js?version=2.0.0"></script><div class="leancloud-app-id" leancloud-app-id="LjOwR4ELEqbauKvtQbwq5TUw-MdYXbMMI"></div><div class="leancloud-app-key" leancloud-app-key="BOSFJ49ohbGctgn4zvJE9VN6"></div><div class="leancloud-app-hot"></div><div class="leancloud-app-visitor"></div></div><link rel="stylesheet" href="/lib/APlayer/APlayer.min.css"><script src="/lib/APlayer/APlayer.min.js"></script><div id="aplayer"></div><script>let list = JSON.parse('[{"name":"Julia，Train，Slow Down","artist":"Whale Fall","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/JuliaTrainSlowDown.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/5.jpg"},{"name":"The Wellwisher","artist":"Halves","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/TheWellwisher.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/4.jpg"},{"name":"SadSexy","artist":"Dirty Three","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/SadSexy .mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/1.jpg"},{"name":"Riverrun","artist":"Stubborn","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/music/Riverrun.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.1/blog/cover/3.jpg"},{"name":"Hortur","artist":"Picastro","url":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/music/Hortur.mp3","cover":"https://cdn.jsdelivr.net/gh/kikyoluka/cdn@2.0/blog/cover/2.jpg"}]')
  const ap = new APlayer({
      container: document.getElementById('aplayer'),
      theme: '#b28fce',
      audio: list,
      fixed: true,
      volume: 1
  });
  ap.list.show()
</script><script src="/js/third-party/jquery.min.js?version=2.0.0"></script><script src="/js/third-party/isMobile.min.js?version=2.0.0"></script><script src="/js/third-party/timeago.min.js?version=2.0.0"></script><script src="/js/third-party/pjax.min.js?version=2.0.0"></script><script src="/js/third-party/zooming.min.js?version=2.0.0"></script><script src="/js/third-party/backstretch.min.js?version=2.0.0"></script><script src="/js/highlight.min.js?version=2.0.0"></script><script src="/js/index.js?version=2.0.0"></script></body></html>